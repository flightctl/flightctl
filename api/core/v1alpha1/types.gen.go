// Package v1alpha1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package v1alpha1

import (
	"encoding/json"
	"fmt"
	"time"

	externalRef0 "github.com/flightctl/flightctl/api/core/v1beta1"
	"github.com/oapi-codegen/runtime"
)

// Defines values for CatalogItemArtifactType.
const (
	CatalogItemArtifactTypeAmi         CatalogItemArtifactType = "ami"
	CatalogItemArtifactTypeAnacondaIso CatalogItemArtifactType = "anaconda-iso"
	CatalogItemArtifactTypeContainer   CatalogItemArtifactType = "container"
	CatalogItemArtifactTypeGce         CatalogItemArtifactType = "gce"
	CatalogItemArtifactTypeIso         CatalogItemArtifactType = "iso"
	CatalogItemArtifactTypeQcow2       CatalogItemArtifactType = "qcow2"
	CatalogItemArtifactTypeRaw         CatalogItemArtifactType = "raw"
	CatalogItemArtifactTypeVhd         CatalogItemArtifactType = "vhd"
	CatalogItemArtifactTypeVmdk        CatalogItemArtifactType = "vmdk"
)

// Defines values for CatalogItemCategory.
const (
	CatalogItemCategoryApplication CatalogItemCategory = "application"
	CatalogItemCategorySystem      CatalogItemCategory = "system"
)

// Defines values for CatalogItemType.
const (
	CatalogItemTypeCompose   CatalogItemType = "compose"
	CatalogItemTypeContainer CatalogItemType = "container"
	CatalogItemTypeData      CatalogItemType = "data"
	CatalogItemTypeDriver    CatalogItemType = "driver"
	CatalogItemTypeFirmware  CatalogItemType = "firmware"
	CatalogItemTypeHelm      CatalogItemType = "helm"
	CatalogItemTypeOS        CatalogItemType = "os"
	CatalogItemTypeQuadlet   CatalogItemType = "quadlet"
)

// Defines values for CatalogItemVisibility.
const (
	CatalogItemVisibilityDraft     CatalogItemVisibility = "draft"
	CatalogItemVisibilityPublished CatalogItemVisibility = "published"
)

// Catalog defines model for Catalog.
type Catalog struct {
	// ApiVersion APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources.
	ApiVersion string `json:"apiVersion"`

	// Kind Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds.
	Kind string `json:"kind"`

	// Metadata ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
	Metadata externalRef0.ObjectMeta `json:"metadata"`

	// Spec CatalogSpec describes the configuration of a catalog. Catalogs are containers for locally-managed CatalogItems.
	Spec CatalogSpec `json:"spec"`

	// Status CatalogStatus represents the current status of a catalog source.
	Status *CatalogStatus `json:"status,omitempty"`
}

// CatalogItem CatalogItem represents an application template from a catalog. It provides default configuration values that can be customized when adding the application to a fleet.
type CatalogItem struct {
	// ApiVersion APIVersion defines the versioned schema of this representation of an object.
	ApiVersion string `json:"apiVersion"`

	// Kind Kind is a string value representing the REST resource this object represents.
	Kind string `json:"kind"`

	// Metadata Metadata for CatalogItem resources. Extends ObjectMeta with catalog scoping.
	Metadata CatalogItemMeta `json:"metadata"`

	// Spec CatalogItemSpec defines the configuration for a catalog item.
	Spec CatalogItemSpec `json:"spec"`
}

// CatalogItemArtifact An alternative artifact format.
type CatalogItemArtifact struct {
	// Name Optional human-readable display name for this artifact.
	Name *string `json:"name,omitempty"`

	// Type Type of artifact format. Includes bootc-image-builder output formats. Defaults to container if only one artifact.
	Type *CatalogItemArtifactType `json:"type,omitempty"`

	// Uri Artifact URI (OCI reference, URL, S3 path, etc.).
	Uri string `json:"uri"`
}

// CatalogItemArtifactType Type of artifact format. Includes bootc-image-builder output formats. Defaults to container if only one artifact.
type CatalogItemArtifactType string

// CatalogItemCategory Category of a catalog item.
type CatalogItemCategory string

// CatalogItemConfigurable Configuration fields that can be specified at item level (as defaults) and overridden at version level. Version-level values fully replace item-level values (not merged).
type CatalogItemConfigurable struct {
	// Config Configuration values (envVars, ports, volumes, resources, etc.).
	Config *map[string]interface{} `json:"config,omitempty"`

	// ConfigSchema JSON Schema defining configurable parameters and their validation.
	ConfigSchema *map[string]interface{} `json:"configSchema,omitempty"`

	// Readme Detailed documentation, preferably in markdown format.
	Readme *string `json:"readme,omitempty"`
}

// CatalogItemDeprecation Deprecation information for a catalog item or version. Presence indicates deprecated status.
type CatalogItemDeprecation struct {
	// Message Required message explaining why this is deprecated and what to do instead.
	Message string `json:"message"`

	// Replacement Optional name of the replacement catalog item (item-level only).
	Replacement *string `json:"replacement,omitempty"`
}

// CatalogItemList CatalogItemList is a list of CatalogItems.
type CatalogItemList struct {
	// ApiVersion APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources.
	ApiVersion string `json:"apiVersion"`

	// Items List of CatalogItems.
	Items []CatalogItem `json:"items"`

	// Kind Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds.
	Kind string `json:"kind"`

	// Metadata ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata externalRef0.ListMeta `json:"metadata"`
}

// CatalogItemMeta defines model for CatalogItemMeta.
type CatalogItemMeta struct {
	// Annotations Properties set by the service.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Catalog The catalog this item belongs to. Similar to namespace in Kubernetes.
	Catalog string `json:"catalog"`

	// CreationTimestamp The time the object was created.
	CreationTimestamp *time.Time `json:"creationTimestamp,omitempty"`

	// DeletionTimestamp The time the object will be deleted.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Generation A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
	Generation *int64 `json:"generation,omitempty"`

	// Labels Map of string keys and values that can be used to organize and categorize (scope and select) objects.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The name of the object.
	Name *string `json:"name,omitempty"`

	// Owner A resource that owns this resource, in "kind/name" format.
	Owner *string `json:"owner,omitempty"`

	// ResourceVersion An opaque string that identifies the server's internal version of an object.
	ResourceVersion *string `json:"resourceVersion,omitempty"`
}

// CatalogItemReference Reference to the primary artifact and optional alternative formats.
type CatalogItemReference struct {
	// Artifacts Alternative artifact formats (e.g., qcow2, ISO for bootc images).
	Artifacts *[]CatalogItemArtifact `json:"artifacts,omitempty"`

	// Uri Primary artifact URI without version tag. Supports OCI references, URLs, S3 paths, etc.
	Uri string `json:"uri"`
}

// CatalogItemSpec CatalogItemSpec defines the configuration for a catalog item.
type CatalogItemSpec struct {
	// Category Category of a catalog item.
	Category *CatalogItemCategory `json:"category,omitempty"`

	// Defaults Configuration fields that can be specified at item level (as defaults) and overridden at version level. Version-level values fully replace item-level values (not merged).
	Defaults *CatalogItemConfigurable `json:"defaults,omitempty"`

	// Deprecation Deprecation information for a catalog item or version. Presence indicates deprecated status.
	Deprecation *CatalogItemDeprecation `json:"deprecation,omitempty"`

	// DisplayName Human-readable display name shown in catalog listings.
	DisplayName *string `json:"displayName,omitempty"`

	// DocumentationUrl Link to external documentation.
	DocumentationUrl *string `json:"documentationUrl,omitempty"`

	// Homepage The homepage URL for the catalog item project.
	Homepage *string `json:"homepage,omitempty"`

	// Icon URL or data URI of the catalog item icon for display in UI.
	Icon *string `json:"icon,omitempty"`

	// Provider Provider or publisher of the catalog item (company or team name).
	Provider *string `json:"provider,omitempty"`

	// Reference Reference to the primary artifact and optional alternative formats.
	Reference CatalogItemReference `json:"reference"`

	// ShortDescription A brief one-line description of the catalog item.
	ShortDescription *string `json:"shortDescription,omitempty"`

	// Support Link to support resources or documentation for getting help.
	Support *string `json:"support,omitempty"`

	// Type Type of catalog item within its category.
	Type CatalogItemType `json:"type"`

	// Versions Available versions using Cincinnati model. Use replaces for primary edge, skips when stable channel skips intermediate versions.
	Versions []CatalogItemVersion `json:"versions"`

	// Visibility Visibility controls who can see and use the catalog item.
	Visibility *CatalogItemVisibility `json:"visibility,omitempty"`
}

// CatalogItemType Type of catalog item within its category.
type CatalogItemType string

// CatalogItemVersion defines model for CatalogItemVersion.
type CatalogItemVersion struct {
	// Channels Channels this version belongs to.
	Channels []string `json:"channels"`

	// Config Configuration values (envVars, ports, volumes, resources, etc.).
	Config *map[string]interface{} `json:"config,omitempty"`

	// ConfigSchema JSON Schema defining configurable parameters and their validation.
	ConfigSchema *map[string]interface{} `json:"configSchema,omitempty"`

	// Deprecation Deprecation information for a catalog item or version. Presence indicates deprecated status.
	Deprecation *CatalogItemDeprecation `json:"deprecation,omitempty"`

	// Digest OCI digest for immutable reference. Mutually exclusive with tag. Format: sha256:...
	Digest *string `json:"digest,omitempty"`

	// Readme Detailed documentation, preferably in markdown format.
	Readme *string `json:"readme,omitempty"`

	// Replaces The single version this one replaces, defining the primary upgrade edge.
	Replaces *string `json:"replaces,omitempty"`

	// SkipRange Semver range of versions that can upgrade directly to this one. Use for z-stream updates or hotfixes.
	SkipRange *string `json:"skipRange,omitempty"`

	// Skips Additional versions that can upgrade directly to this one. Use when stable channel skips intermediate fast-only versions.
	Skips *[]string `json:"skips,omitempty"`

	// Tag Image tag to pull. Mutually exclusive with digest.
	Tag *string `json:"tag,omitempty"`

	// Version Semantic version identifier (e.g., 1.2.3, v2.0.0-rc1). Required for version ordering and upgrade graph.
	Version string `json:"version"`
	union   json.RawMessage
}

// CatalogItemVersion0 defines model for .
type CatalogItemVersion0 = interface{}

// CatalogItemVersion1 defines model for .
type CatalogItemVersion1 = interface{}

// CatalogItemVisibility Visibility controls who can see and use the catalog item.
type CatalogItemVisibility string

// CatalogList CatalogList is a list of Catalogs.
type CatalogList struct {
	// ApiVersion APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources.
	ApiVersion string `json:"apiVersion"`

	// Items List of Catalogs.
	Items []Catalog `json:"items"`

	// Kind Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds.
	Kind string `json:"kind"`

	// Metadata ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
	Metadata externalRef0.ListMeta `json:"metadata"`
}

// CatalogSpec CatalogSpec describes the configuration of a catalog. Catalogs are containers for locally-managed CatalogItems.
type CatalogSpec struct {
	// DisplayName Human-readable display name shown in catalog listings.
	DisplayName *string `json:"displayName,omitempty"`

	// Icon URL or data URI of the catalog icon for display in UI.
	Icon *string `json:"icon,omitempty"`

	// Provider Provider or publisher of the catalog (company or team name).
	Provider *string `json:"provider,omitempty"`

	// ShortDescription A brief one-line description of the catalog.
	ShortDescription *string `json:"shortDescription,omitempty"`

	// Support Link to support resources or documentation for getting help.
	Support *string `json:"support,omitempty"`

	// Visibility Visibility controls who can see and use the catalog item.
	Visibility *CatalogItemVisibility `json:"visibility,omitempty"`
}

// CatalogStatus CatalogStatus represents the current status of a catalog source.
type CatalogStatus struct {
	// Conditions Current state of the catalog source.
	Conditions []externalRef0.Condition `json:"conditions"`
}

// ListCatalogsParams defines parameters for ListCatalogs.
type ListCatalogsParams struct {
	// Continue An optional parameter to query more results from the server. The value of the paramter must match the value of the 'continue' field in the previous list response.
	Continue *string `form:"continue,omitempty" json:"continue,omitempty"`

	// LabelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
	LabelSelector *string `form:"labelSelector,omitempty" json:"labelSelector,omitempty"`

	// FieldSelector A selector to restrict the list of returned objects by their fields, supporting operators like '=', '==', and '!=' (e.g., "key1=value1,key2!=value2").
	FieldSelector *string `form:"fieldSelector,omitempty" json:"fieldSelector,omitempty"`

	// Limit The maximum number of results returned in the list response. The server will set the 'continue' field in the list response if more results exist. The continue value may then be specified as parameter in a subsequent query.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListCatalogItemsParams defines parameters for ListCatalogItems.
type ListCatalogItemsParams struct {
	// Continue An optional parameter to query more results from the server.
	Continue *string `form:"continue,omitempty" json:"continue,omitempty"`

	// LabelSelector A selector to restrict the list of returned objects by their labels.
	LabelSelector *string `form:"labelSelector,omitempty" json:"labelSelector,omitempty"`

	// Limit The maximum number of results returned in the list response.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateCatalogJSONRequestBody defines body for CreateCatalog for application/json ContentType.
type CreateCatalogJSONRequestBody = Catalog

// CreateCatalogItemJSONRequestBody defines body for CreateCatalogItem for application/json ContentType.
type CreateCatalogItemJSONRequestBody = CatalogItem

// ReplaceCatalogItemJSONRequestBody defines body for ReplaceCatalogItem for application/json ContentType.
type ReplaceCatalogItemJSONRequestBody = CatalogItem

// PatchCatalogApplicationJSONPatchPlusJSONRequestBody defines body for PatchCatalog for application/json-patch+json ContentType.
type PatchCatalogApplicationJSONPatchPlusJSONRequestBody = externalRef0.PatchRequest

// ReplaceCatalogJSONRequestBody defines body for ReplaceCatalog for application/json ContentType.
type ReplaceCatalogJSONRequestBody = Catalog

// PatchCatalogStatusApplicationJSONPatchPlusJSONRequestBody defines body for PatchCatalogStatus for application/json-patch+json ContentType.
type PatchCatalogStatusApplicationJSONPatchPlusJSONRequestBody = externalRef0.PatchRequest

// ReplaceCatalogStatusJSONRequestBody defines body for ReplaceCatalogStatus for application/json ContentType.
type ReplaceCatalogStatusJSONRequestBody = Catalog

// AsCatalogItemVersion0 returns the union data inside the CatalogItemVersion as a CatalogItemVersion0
func (t CatalogItemVersion) AsCatalogItemVersion0() (CatalogItemVersion0, error) {
	var body CatalogItemVersion0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCatalogItemVersion0 overwrites any union data inside the CatalogItemVersion as the provided CatalogItemVersion0
func (t *CatalogItemVersion) FromCatalogItemVersion0(v CatalogItemVersion0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCatalogItemVersion0 performs a merge with any union data inside the CatalogItemVersion, using the provided CatalogItemVersion0
func (t *CatalogItemVersion) MergeCatalogItemVersion0(v CatalogItemVersion0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCatalogItemVersion1 returns the union data inside the CatalogItemVersion as a CatalogItemVersion1
func (t CatalogItemVersion) AsCatalogItemVersion1() (CatalogItemVersion1, error) {
	var body CatalogItemVersion1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCatalogItemVersion1 overwrites any union data inside the CatalogItemVersion as the provided CatalogItemVersion1
func (t *CatalogItemVersion) FromCatalogItemVersion1(v CatalogItemVersion1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCatalogItemVersion1 performs a merge with any union data inside the CatalogItemVersion, using the provided CatalogItemVersion1
func (t *CatalogItemVersion) MergeCatalogItemVersion1(v CatalogItemVersion1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CatalogItemVersion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Channels != nil {
		object["channels"], err = json.Marshal(t.Channels)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'channels': %w", err)
		}
	}

	if t.Config != nil {
		object["config"], err = json.Marshal(t.Config)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config': %w", err)
		}
	}

	if t.ConfigSchema != nil {
		object["configSchema"], err = json.Marshal(t.ConfigSchema)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'configSchema': %w", err)
		}
	}

	if t.Deprecation != nil {
		object["deprecation"], err = json.Marshal(t.Deprecation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deprecation': %w", err)
		}
	}

	if t.Digest != nil {
		object["digest"], err = json.Marshal(t.Digest)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'digest': %w", err)
		}
	}

	if t.Readme != nil {
		object["readme"], err = json.Marshal(t.Readme)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'readme': %w", err)
		}
	}

	if t.Replaces != nil {
		object["replaces"], err = json.Marshal(t.Replaces)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'replaces': %w", err)
		}
	}

	if t.SkipRange != nil {
		object["skipRange"], err = json.Marshal(t.SkipRange)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'skipRange': %w", err)
		}
	}

	if t.Skips != nil {
		object["skips"], err = json.Marshal(t.Skips)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'skips': %w", err)
		}
	}

	if t.Tag != nil {
		object["tag"], err = json.Marshal(t.Tag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tag': %w", err)
		}
	}

	object["version"], err = json.Marshal(t.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *CatalogItemVersion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["channels"]; found {
		err = json.Unmarshal(raw, &t.Channels)
		if err != nil {
			return fmt.Errorf("error reading 'channels': %w", err)
		}
	}

	if raw, found := object["config"]; found {
		err = json.Unmarshal(raw, &t.Config)
		if err != nil {
			return fmt.Errorf("error reading 'config': %w", err)
		}
	}

	if raw, found := object["configSchema"]; found {
		err = json.Unmarshal(raw, &t.ConfigSchema)
		if err != nil {
			return fmt.Errorf("error reading 'configSchema': %w", err)
		}
	}

	if raw, found := object["deprecation"]; found {
		err = json.Unmarshal(raw, &t.Deprecation)
		if err != nil {
			return fmt.Errorf("error reading 'deprecation': %w", err)
		}
	}

	if raw, found := object["digest"]; found {
		err = json.Unmarshal(raw, &t.Digest)
		if err != nil {
			return fmt.Errorf("error reading 'digest': %w", err)
		}
	}

	if raw, found := object["readme"]; found {
		err = json.Unmarshal(raw, &t.Readme)
		if err != nil {
			return fmt.Errorf("error reading 'readme': %w", err)
		}
	}

	if raw, found := object["replaces"]; found {
		err = json.Unmarshal(raw, &t.Replaces)
		if err != nil {
			return fmt.Errorf("error reading 'replaces': %w", err)
		}
	}

	if raw, found := object["skipRange"]; found {
		err = json.Unmarshal(raw, &t.SkipRange)
		if err != nil {
			return fmt.Errorf("error reading 'skipRange': %w", err)
		}
	}

	if raw, found := object["skips"]; found {
		err = json.Unmarshal(raw, &t.Skips)
		if err != nil {
			return fmt.Errorf("error reading 'skips': %w", err)
		}
	}

	if raw, found := object["tag"]; found {
		err = json.Unmarshal(raw, &t.Tag)
		if err != nil {
			return fmt.Errorf("error reading 'tag': %w", err)
		}
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &t.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
	}

	return err
}
