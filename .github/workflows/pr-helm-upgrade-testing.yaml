name: "Helm upgrade test"
description: |
  Tests Helm upgrade path from target branch to PR changes.
  Builds images/charts for both target branch (baseline) and PR branch in parallel,
  deploys baseline to kind cluster, runs smoke tests, then upgrades to PR version
  and verifies resources are preserved. For PRs targeting release branches,
  uses that release branch as baseline instead of main. 

on:
  workflow_dispatch:
  pull_request:
  merge_group:

permissions:
  contents: read
  pull-requests: read

env:
  DOCKER_BUILDKIT: 1
  BUILDKIT_PROGRESS: plain
  QUAY_ORG: quay.io/flightctl
  REGISTRY: quay.io
  REGISTRY_OWNER: flightctl
  REGISTRY_OWNER_TESTS: flightctl-tests
  GITHUB_ACTIONS: true

jobs:
  check-override:
    runs-on: ubuntu-24.04
    outputs:
      override: ${{ steps.check_override.outputs.override }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Check if override label exists
        id: check_override
        uses: ./.github/actions/check-reviewer-override
        with:
          label-name: 'breaking-helm-change-approved'

  check-changes:
    runs-on: ubuntu-24.04
    outputs:
      any_changed: ${{ steps.changed-files.outputs.any_changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v46
        with:
          since_last_remote_commit: 'true'
          files_ignore: |
            .spelling
            README.md
            docs/**
            examples/**
            packaging/rpm/**

  build-baseline:
    needs: [check-changes]
    if: needs.check-changes.outputs.any_changed == 'true'
    uses: ./.github/workflows/build-images-and-charts.yaml
    with:
      repository: flightctl/flightctl
      ref: ${{ github.base_ref || 'main' }}

  build-pr:
    needs: [check-changes]
    if: needs.check-changes.outputs.any_changed == 'true'
    uses: ./.github/workflows/build-images-and-charts.yaml

  deploy-and-upgrade:
    runs-on: ubuntu-24.04
    needs: [check-override, check-changes, build-baseline, build-pr]
    if: needs.check-changes.outputs.any_changed == 'true'
    continue-on-error: ${{ needs.check-override.outputs.override == 'true' }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Free disk space (in background)
        run: |
          sudo rm -rf /usr/local/lib/android >/dev/null 2>&1 &
          echo "Started background removal of /usr/local/lib/android (PID: $!)"
          df -h

      - name: Setup tools
        run: |
          set -euo pipefail
          
          echo "Installing yq..."
          sudo wget -qO /usr/local/bin/yq \
            https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          echo "yq version:"
          yq --version
          echo ""
          
          echo "Helm version:"
          helm version
          echo ""
          echo "Installed Helm plugins:"
          helm plugin list || echo "No plugins installed"
          echo ""
          echo "Installing helm-diff plugin..."
          helm plugin install https://github.com/databus23/helm-diff || echo "Plugin already installed"
          echo ""
          echo "Helm plugins after installation:"
          helm plugin list

      # ========== DEPLOY BASELINE (target branch) ==========
      - name: Get base domain
        id: get-ip
        run: |
          source ./test/scripts/functions
          BASE_DOMAIN=$(get_ext_ip).nip.io
          echo "$BASE_DOMAIN"
          echo "base-domain=$BASE_DOMAIN" >> "$GITHUB_OUTPUT"

      - name: "[BASELINE] Deploy"
        id: deploy-baseline
        uses: ./.github/actions/deploy-backend-with-helm
        with:
          tag: ${{ needs.build-baseline.outputs.git_tag }}
          base-domain: ${{ steps.get-ip.outputs.base-domain }}
          flavor: el9

      - name: "[BASELINE] Check deployment"
        run: kubectl get pods --all-namespaces

      - name: "[BASELINE] Login"
        env:
          BASE_DOMAIN: ${{ steps.get-ip.outputs.base-domain }}
        run: |
          TOKEN=$(kubectl -n flightctl-external create token flightctl-admin --duration=8h --context kind-kind)
          ./bin/flightctl login -k https://api.${BASE_DOMAIN}:3443 --token "$TOKEN"
          ./bin/flightctl version

      - name: "[BASELINE] Validate versions"
        env:
          EXPECTED_CLIENT_TAG: ${{ needs.build-baseline.outputs.cli_git_tag }}
          EXPECTED_SERVER_TAG: ${{ needs.build-baseline.outputs.git_tag }}
        run: |
          set -euo pipefail
          CLIENT_VERSION=$(./bin/flightctl version | grep "Client Version:" | awk '{print $3}')
          SERVER_VERSION=$(./bin/flightctl version | grep "Server Version:" | awk '{print $3}')
          
          [ "${CLIENT_VERSION}" = "${EXPECTED_CLIENT_TAG}" ] || { echo "Client version mismatch: ${CLIENT_VERSION} != ${EXPECTED_CLIENT_TAG}"; exit 1; }
          [ "${SERVER_VERSION}" = "${EXPECTED_SERVER_TAG}" ] || { echo "Server version mismatch: ${SERVER_VERSION} != ${EXPECTED_SERVER_TAG}"; exit 1; }
          
          echo "✓ Versions validated: Client=${CLIENT_VERSION}, Server=${SERVER_VERSION}"

      - name: "[BASELINE] Apply test resources"
        run: |
          bin/flightctl apply -f examples/device.yaml
          bin/flightctl apply -f examples/fleet.yaml
          bin/flightctl apply -f examples/enrollmentrequest.yaml
          bin/flightctl apply -f examples/repository-flightctl.yaml
          bin/flightctl apply -f examples/resourcesync.yaml


      - name: "[BASELINE] Download simulator"
        uses: actions/download-artifact@v4
        with:
          name: devicesimulator-el9-${{ needs.build-baseline.outputs.cli_git_tag }}
          path: bin-baseline-sim

      - name: "[BASELINE] Run simulator"
        run: |
          make prepare-agent-config
          chmod +x bin-baseline-sim/devicesimulator
          bin-baseline-sim/devicesimulator --config bin/agent/etc/flightctl/config.yaml --count 10 --stop-after 1m 2>&1 | tee simulator-baseline.log

      - name: "[BASELINE] Check simulator logs"
        uses: ./.github/actions/check-simulator-logs
        with:
          log-file: simulator-baseline.log

      # ========== UPGRADE TO PR BRANCH ==========
      - name: "[HEAD] Download artifacts"
        uses: actions/download-artifact@v4
        with:
          pattern: "*-${{ needs.build-pr.outputs.git_tag }}"
          path: artifacts-pr
          merge-multiple: true

      - name: "[HEAD] Load images"
        env:
          PR_GIT_TAG: ${{ needs.build-pr.outputs.git_tag }}
        run: |
          set -euo pipefail
          echo "Loading PR branch backend images into kind"
          # Image bundle file (artifact name is flavor-specific, but file inside is fixed)
          BUNDLE_FILE="artifacts-pr/flightctl-images-bundle.tar"
          if [[ ! -f "$BUNDLE_FILE" ]]; then
            echo "Image bundle not found at $BUNDLE_FILE. Available files:"
            find artifacts-pr -name "*.tar" || true
            ls -la artifacts-pr/
            exit 1
          fi
          echo "Using bundle file: $BUNDLE_FILE"
          kind load image-archive "${BUNDLE_FILE}"
          echo "PR images loaded successfully"
          rm -f "${BUNDLE_FILE}"

      - name: "[HEAD] Download CLI"
        uses: actions/download-artifact@v4
        with:
          name: flightctl-linux-amd64-el9-${{ needs.build-pr.outputs.cli_git_tag }}
          path: bin-pr

      - name: "[HEAD] Setup CLI"
        run: |
          set -euo pipefail
          chmod +x bin-pr/flightctl-linux-amd64
          mv bin-pr/flightctl-linux-amd64 bin-pr/flightctl
          bin-pr/flightctl version

      - name: "[HEAD] Helm diff"
        env:
          PR_GIT_TAG: ${{ needs.build-pr.outputs.git_tag }}
        run: |
          set -euo pipefail
          # Find the chart file (artifact name is flavor-specific, but file inside is fixed)
          CHART_FILE="artifacts-pr/flightctl-chart.tgz"
          if [[ ! -f "$CHART_FILE" ]]; then
            echo "Chart file not found at $CHART_FILE. Available files:"
            find artifacts-pr -name "*.tgz" || true
            ls -la artifacts-pr/
            exit 1
          fi
          echo "Using chart file: $CHART_FILE"
          helm diff upgrade flightctl "${CHART_FILE}" \
            --namespace flightctl-external \
            --reuse-values \
            --dry-run=server \
            --output=dyff \
            --debug

      - name: "[HEAD] Show cluster state before upgrade"
        run: |
          echo "=== Pre-upgrade cluster state ==="
          kubectl get pods --all-namespaces --show-labels | grep -E "(flightctl|cert-generator|upgrade)" || echo "No matching pods"
          kubectl get jobs --all-namespaces --show-labels | grep -E "(flightctl|cert-generator|upgrade)" || echo "No matching jobs"
          kubectl get serviceaccounts --all-namespaces | grep -E "(flightctl|cert-generator|upgrade)" || echo "No matching serviceaccounts"
          echo "=== End pre-upgrade state ==="

      - name: "[HEAD] Helm upgrade with migration monitoring"
        env:
          PR_GIT_TAG: ${{ needs.build-pr.outputs.git_tag }}
        run: |
          # Chart file (artifact name is flavor-specific, but file inside is fixed)
          CHART_FILE="artifacts-pr/flightctl-chart.tgz"
          if [[ ! -f "$CHART_FILE" ]]; then
            echo "Chart file not found at $CHART_FILE. Available files:"
            find artifacts-pr -name "*.tgz" || true
            ls -la artifacts-pr/
            exit 1
          fi
          echo "Using chart file: $CHART_FILE"

          # Auto-detect image tag format for backward compatibility (same as deploy-backend-with-helm)
          BASELINE_TAG="${PR_GIT_TAG}"
          FLAVOR_TAG="el9-${BASELINE_TAG}"

          # Check if flavor-prefixed images exist by looking for API image (always present)
          if docker exec kind-control-plane crictl images | grep -q "flightctl-api.*:${IMAGE_TAG}"; then
            echo "Found flavor-prefixed images, using: ${IMAGE_TAG}"
            IMAGE_TAG="${IMAGE_TAG}"
          else
            echo "No flavor-prefixed images found, using baseline tag: ${BASELINE_TAG}"
            IMAGE_TAG="${BASELINE_TAG}"
          fi

          # Start migration monitoring in background
          (
            echo "=== Starting migration job monitoring ==="
            sleep 5  # Give helm a moment to start

            MONITOR_COUNT=0
            while [ $MONITOR_COUNT -lt 40 ]; do  # Monitor for up to 20 minutes (40 * 30s)
              echo "=== Migration Monitor Check $((MONITOR_COUNT + 1)) at $(date) ==="

              # Show migration jobs
              echo "--- Migration Jobs ---"
              kubectl get jobs -n flightctl-internal --show-labels | grep -E "(migration|dryrun)" || echo "No migration jobs found"

              # Show migration job details if any exist
              MIGRATION_JOBS=$(kubectl get jobs -n flightctl-internal -o name | grep -E "(migration|dryrun)" || true)
              if [ -n "$MIGRATION_JOBS" ]; then
                for job in $MIGRATION_JOBS; do
                  echo "--- Job Details: $job ---"
                  kubectl describe "$job" -n flightctl-internal | tail -15 || true

                  # Show pod logs if available
                  echo "--- Job Pod Logs: $job ---"
                  JOB_PODS=$(kubectl get pods -n flightctl-internal --selector=job-name=$(basename "$job") -o name 2>/dev/null || true)
                  if [ -n "$JOB_PODS" ]; then
                    for pod in $JOB_PODS; do
                      echo "--- Pod logs: $pod ---"
                      kubectl logs "$pod" -n flightctl-internal --tail=10 2>/dev/null || echo "No logs available"
                    done
                  fi
                done
              fi

              # Show hook resources
              echo "--- Pre-upgrade Hook Resources ---"
              kubectl get pods,jobs -n flightctl-internal --show-labels | grep -E "(hook|upgrade)" || echo "No hook resources found"

              sleep 30
              MONITOR_COUNT=$((MONITOR_COUNT + 1))
            done
            echo "=== Migration monitoring completed ==="
          ) &
          MONITOR_PID=$!

          echo "=== Starting helm upgrade with image tag: ${IMAGE_TAG} ==="
          echo "Migration monitoring started with PID: $MONITOR_PID"

          # Run helm upgrade with timeout handling
          if timeout 20m helm upgrade flightctl "${CHART_FILE}" \
            --namespace flightctl-external \
            --reuse-values \
            --set dbSetup.image.tag="${IMAGE_TAG}" \
            --set api.image.tag="${IMAGE_TAG}" \
            --set worker.image.tag="${IMAGE_TAG}" \
            --set periodic.image.tag="${IMAGE_TAG}" \
            --set alertExporter.image.tag="${IMAGE_TAG}" \
            --set alertmanagerProxy.image.tag="${IMAGE_TAG}" \
            --set cliArtifacts.image.tag="${IMAGE_TAG}" \
            --set telemetryGateway.image.tag="${IMAGE_TAG}" \
            --set imageBuilderApi.image.tag="${IMAGE_TAG}" \
            --set imageBuilderWorker.image.tag="${IMAGE_TAG}" \
            --debug --wait; then
            echo "=== Helm upgrade completed successfully ==="
          else
            EXIT_CODE=$?
            echo "=== Helm upgrade failed with exit code $EXIT_CODE ==="

            # Show final state for debugging
            echo "=== Final Migration State ==="
            kubectl get jobs,pods -n flightctl-internal --show-labels | grep -E "(migration|dryrun|hook)" || echo "No migration resources found"

            # Kill monitoring process
            kill $MONITOR_PID 2>/dev/null || true
            exit $EXIT_CODE
          fi

          # Kill monitoring process on success
          kill $MONITOR_PID 2>/dev/null || true

      - name: "[HEAD] Show cluster state after failed upgrade"
        if: failure()
        run: |
          echo "=== Post-failure cluster state ==="
          kubectl get pods --all-namespaces --show-labels | grep -E "(flightctl|cert-generator|upgrade)" || echo "No matching pods"
          kubectl get jobs --all-namespaces --show-labels | grep -E "(flightctl|cert-generator|upgrade)" || echo "No matching jobs"
          kubectl describe jobs --all-namespaces | grep -A30 -B5 -E "(flightctl|cert-generator|upgrade)" || echo "No job details"
          echo "=== Checking for stuck resources ==="
          kubectl get events --all-namespaces --sort-by='.lastTimestamp' | tail -20
          echo "=== End post-failure state ==="

      - name: "[HEAD] Wait for API readiness after upgrade"
        uses: ./.github/actions/wait-for-api-readiness
        with:
          base-domain: ${{ steps.get-ip.outputs.base-domain }}

      - name: "[HEAD] Check deployment"
        run: |
          helm list --all-namespaces
          kubectl get pods --all-namespaces


      - name: "[HEAD] Validate versions"
        env:
          EXPECTED_CLIENT_TAG: ${{ needs.build-pr.outputs.cli_git_tag }}
          EXPECTED_SERVER_TAG: ${{ needs.build-pr.outputs.git_tag }}
        run: |
          set -euo pipefail
          CLIENT_VERSION=$(./bin-pr/flightctl version | grep "Client Version:" | awk '{print $3}')
          SERVER_VERSION=$(./bin-pr/flightctl version | grep "Server Version:" | awk '{print $3}')
          
          [ "${CLIENT_VERSION}" = "${EXPECTED_CLIENT_TAG}" ] || { echo "Client version mismatch: ${CLIENT_VERSION} != ${EXPECTED_CLIENT_TAG}"; exit 1; }
          [ "${SERVER_VERSION}" = "${EXPECTED_SERVER_TAG}" ] || { echo "Server version mismatch: ${SERVER_VERSION} != ${EXPECTED_SERVER_TAG}"; exit 1; }
          
          echo "✓ Versions validated: Client=${CLIENT_VERSION}, Server=${SERVER_VERSION}"

      - name: "[HEAD] Verify resources"
        run: |
          set -euo pipefail
          
          for resource in dev fleet er repo rs; do
            echo "Checking ${resource}..."
            ./bin-pr/flightctl get ${resource}
            ./bin-pr/flightctl get ${resource} -o=yaml > /dev/null
            echo "✓ ${resource} verified"
            echo ""
          done

      - name: "[HEAD] Download simulator"
        uses: actions/download-artifact@v4
        with:
          name: devicesimulator-el9-${{ needs.build-pr.outputs.cli_git_tag }}
          path: bin-pr-sim

      - name: "[HEAD] Run simulator"
        run: |
          make prepare-agent-config
          chmod +x bin-pr-sim/devicesimulator
          bin-pr-sim/devicesimulator --config bin/agent/etc/flightctl/config.yaml --count 10 --stop-after 1m 2>&1 | tee simulator-pr.log

      - name: "[HEAD] Check simulator logs"
        uses: ./.github/actions/check-simulator-logs
        with:
          log-file: simulator-pr.log

      - name: "[HEAD] Run baseline simulator (backward compat)"
        run: |
          bin-baseline-sim/devicesimulator --config bin/agent/etc/flightctl/config.yaml --count 10 --stop-after 1m 2>&1 | tee simulator-compat.log

      - name: "[HEAD] Check backward compat simulator logs"
        uses: ./.github/actions/check-simulator-logs
        with:
          log-file: simulator-compat.log

      - name: "[HEAD] Helm upgrade - to the same version"
        env:
          PR_GIT_TAG: ${{ needs.build-pr.outputs.git_tag }}
        run: |
          # Chart file (artifact name is flavor-specific, but file inside is fixed)
          CHART_FILE="artifacts-pr/flightctl-chart.tgz"
          if [[ ! -f "$CHART_FILE" ]]; then
            echo "Chart file not found at $CHART_FILE. Available files:"
            find artifacts-pr -name "*.tgz" || true
            ls -la artifacts-pr/
            exit 1
          fi
          echo "Using chart file: $CHART_FILE"

          helm upgrade flightctl "${CHART_FILE}" \
            --namespace flightctl-external \
            --reuse-values \
            --set dbSetup.image.tag="el9-${PR_GIT_TAG}" \
            --debug --wait

      - name: "[HEAD] Wait for API readiness after same-version upgrade"
        uses: ./.github/actions/wait-for-api-readiness
        with:
          base-domain: ${{ steps.get-ip.outputs.base-domain }}

      - name: "[HEAD] Validate versions"
        env:
          EXPECTED_CLIENT_TAG: ${{ needs.build-pr.outputs.cli_git_tag }}
          EXPECTED_SERVER_TAG: ${{ needs.build-pr.outputs.git_tag }}
        run: |
          set -euo pipefail
          CLIENT_VERSION=$(./bin-pr/flightctl version | grep "Client Version:" | awk '{print $3}')
          SERVER_VERSION=$(./bin-pr/flightctl version | grep "Server Version:" | awk '{print $3}')
          
          [ "${CLIENT_VERSION}" = "${EXPECTED_CLIENT_TAG}" ] || { echo "Client version mismatch: ${CLIENT_VERSION} != ${EXPECTED_CLIENT_TAG}"; exit 1; }
          [ "${SERVER_VERSION}" = "${EXPECTED_SERVER_TAG}" ] || { echo "Server version mismatch: ${SERVER_VERSION} != ${EXPECTED_SERVER_TAG}"; exit 1; }
          
          echo "✓ Versions validated: Client=${CLIENT_VERSION}, Server=${SERVER_VERSION}"
          
          ./bin-pr/flightctl get dev 

      - name: Collect and Upload Logs
        if: always()
        uses: ./.github/actions/collect-logs
        with:
          namespace-external: 'flightctl-external'
          namespace-internal: 'flightctl-internal'
          log-directory: 'upgrade-logs'

      - name: Finalize
        if: always()
        env:
          OVERRIDE: ${{ needs.check-override.outputs.override }}
        run: |
          if [ "${OVERRIDE}" = "true" ]; then
            echo "Override active - job passes regardless of previous failures"
            exit 0
          fi

  status:
    runs-on: ubuntu-24.04
    needs: [check-override, deploy-and-upgrade]
    if: always() && needs.check-override.outputs.override == 'true'
    steps:
      - name: Log helm upgrade test override status
        env:
          DEPLOY_RESULT: ${{ needs.deploy-and-upgrade.result }}
        run: |
          echo ""
          echo "================================================"
          echo "HELM UPGRADE TEST - OVERRIDE ACTIVE"
          echo "================================================"
          echo ""
          echo "The 'breaking-helm-change-approved' label is present."
          echo "Test result: ${DEPLOY_RESULT}"
          if [ "${DEPLOY_RESULT}" = "failure" ]; then
            echo "Failures were detected but are being ignored due to the override label."
          fi
          exit 0