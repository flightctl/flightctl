name: "PR Build Artifacts"
permissions:
  pull-requests: write
  issues: write
on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      expires_after:
        description: "TTL for images label quay.expires-after (empty = no TTL)"
        required: false
        default: "8h"
        type: string

env:
  # Enable BuildKit for cache mounts
  DOCKER_BUILDKIT: 1
  BUILDKIT_PROGRESS: plain
  GITHUB_ACTIONS: true
  # Define the total number of parallel nodes for Ginkgo
  GINKGO_TOTAL_NODES: 8

jobs:
  compute-tag:
    runs-on: ubuntu-24.04
    outputs:
      tag: ${{ steps.compute-tag.outputs.tag }}
      git_tag: ${{ steps.compute-tag.outputs.git_tag }}
      git_tree_state: ${{ steps.compute-tag.outputs.git_tree_state }}
      git_commit: ${{ steps.compute-tag.outputs.git_commit }}
      helm_tag: ${{ steps.compute-tag.outputs.helm_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Compute tag
        id: compute-tag
        run: |
          set -euo pipefail
          TAG=$(./hack/current-version)
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Computed tag: $TAG"
          
          # Normalize for helm (drop leading v, replace ~ with -)
          HELM_TAG=$(echo "${TAG#v}" | sed 's/~/-/g')
          echo "helm_tag=${HELM_TAG}" >> "$GITHUB_OUTPUT"
          
          SOURCE_GIT_TAG=$(git describe --tags --exclude latest 2>/dev/null || echo "v0.0.0-unknown")
          if [ ! -d ".git" ]; then
            SOURCE_GIT_TREE_STATE=clean
          elif git diff --quiet; then
            SOURCE_GIT_TREE_STATE=clean
          else
            SOURCE_GIT_TREE_STATE=dirty
          fi
          SOURCE_GIT_COMMIT=$(git rev-parse --short "HEAD^{commit}" 2>/dev/null || echo "unknown")
          
          {
            echo "git_tag=${SOURCE_GIT_TAG}"
            echo "git_tree_state=${SOURCE_GIT_TREE_STATE}"
            echo "git_commit=${SOURCE_GIT_COMMIT}"
          } >> "$GITHUB_OUTPUT"
          
          echo "## :rocket: PR Build Artifacts Workflow Started" > $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag:** \`${TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** \`${GITHUB_SHA:0:7}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** \`${GITHUB_REF_NAME}\`" >> $GITHUB_STEP_SUMMARY

  build-images:
    needs: [compute-tag]
    strategy:
      matrix:
        image: ['api', 'periodic', 'worker', 'cli-artifacts', 'alert-exporter', 'alertmanager-proxy', 'userinfo-proxy', 'db-setup', 'telemetry-gateway']
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set up build output dir
        run: |
          mkdir -p digests

      - name: Build image
        id: build
        uses: redhat-actions/buildah-build@v2
        with:
          image: quay.io/flightctl/flightctl-${{ matrix.image }}
          tags: ${{ needs.compute-tag.outputs.tag }}
          labels: |
            io.flightctl.flightctl-${{ matrix.image }}.github.repository=${{ github.repository }}
            io.flightctl.flightctl-${{ matrix.image }}.github.actor=${{ github.actor }}
            io.flightctl.flightctl-${{ matrix.image }}.github.run_id=${{ github.run_id }}
            io.flightctl.flightctl-${{ matrix.image }}.github.sha=${{ github.sha }}
            io.flightctl.flightctl-${{ matrix.image }}.github.ref_name=${{ github.ref_name }}
            quay.expires-after=${{ inputs.expires_after }}
          build-args: |
            SOURCE_GIT_TAG=${{ needs.compute-tag.outputs.git_tag }}
            SOURCE_GIT_TREE_STATE=${{ needs.compute-tag.outputs.git_tree_state }}
            SOURCE_GIT_COMMIT=${{ needs.compute-tag.outputs.git_commit }}
          extra-args: |
            --ulimit nofile=10000:10000
          containerfiles: Containerfile.${{ matrix.image }}
          context: .

      - name: Tag and save image archive
        id: save
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE: ${{ steps.build.outputs.image }}      # e.g. quay.io/org/flightctl
          MATRIX_IMAGE: ${{ matrix.image }}            # e.g. api, worker
        run: |
          set -euo pipefail
          
          ARCHIVE_NAME="image-flightctl-${MATRIX_IMAGE}.tar"
          
          echo "Saving ${IMAGE}:${TAG} to ${ARCHIVE_NAME}"
          podman save -o "${ARCHIVE_NAME}" "${IMAGE}:${TAG}"
          
          mkdir -p digests
          
          DIGEST="$(podman inspect "${IMAGE}:${TAG}" --format '{{.Digest}}' || true)"
          DIGEST_FILE="digests/${MATRIX_IMAGE}.txt"
          printf "%s\n" "${DIGEST}" > "${DIGEST_FILE}"
          echo "Digest: ${DIGEST}"
          
          {
            echo "archive=${ARCHIVE_NAME}"
            echo "digest=${DIGEST}"
            echo "digest_file=${DIGEST_FILE}"
          } >> "$GITHUB_OUTPUT"

      - name: Upload image archive
        uses: actions/upload-artifact@v4
        with:
          name: image-flightctl-${{ matrix.image }}
          path: ${{ steps.save.outputs.archive }}
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

      - name: Upload digest artifact
        uses: actions/upload-artifact@v4
        with:
          name: digest-${{ matrix.image }}
          path: ${{ steps.save.outputs.digest_file }}
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

  build-auxiliary-images:
    runs-on: ubuntu-24.04
    needs: [compute-tag]
    strategy:
      matrix:
        image: ['git-server']
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Build image
        id: build
        uses: redhat-actions/buildah-build@v2
        with:
          image: quay.io/flightctl-tests/${{ matrix.image }}
          tags: ${{ needs.compute-tag.outputs.tag }}
          labels: |
            org.flightctl.${{ matrix.image }}.github.repository=${{ github.repository }}
            org.flightctl.${{ matrix.image }}.github.actor=${{ github.actor }}
            org.flightctl.${{ matrix.image }}.github.run_id=${{ github.run_id }}
            org.flightctl.${{ matrix.image }}.github.sha=${{ github.sha }}
            org.flightctl.${{ matrix.image }}.github.ref_name=${{ github.ref_name }}
          containerfiles: test/scripts/auxiliary-images-v2/Containerfile.${{ matrix.image }}
          context: .

      - name: Save image archive
        id: save
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE: ${{ steps.build.outputs.image }}
          MATRIX_IMAGE: ${{ matrix.image }}
        run: |
          set -euo pipefail
          
          ARCHIVE_NAME="auxiliary-image-${MATRIX_IMAGE}.tar"
          
          echo "Saving ${IMAGE}:${TAG} to ${ARCHIVE_NAME}"
          podman save -o "${ARCHIVE_NAME}" "${IMAGE}:${TAG}"
          
          echo "archive=${ARCHIVE_NAME}" >> "$GITHUB_OUTPUT"

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: auxiliary-image-${{ matrix.image }}
          path: ${{ steps.save.outputs.archive }}
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

  bundle-images:
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-images]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load images using artifact loader script
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          RUN_ID: ${{ github.run_id }}
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          echo "::group::Loading individual image archives using artifact loader"
          images=('api' 'periodic' 'worker' 'cli-artifacts' 'alert-exporter' 'alertmanager-proxy' 'userinfo-proxy' 'db-setup' 'telemetry-gateway')

          for image in "${images[@]}"; do
            artifact_name="image-flightctl-${image}"
            echo "Loading artifact: $artifact_name"
            ./hack/load-github-artifact.sh "$artifact_name" "$RUN_ID" "$REPO"
          done
          echo "::endgroup::"

          echo "::group::Creating images bundle"
          echo "Getting list of loaded flightctl images with tag: $TAG"
          mapfile -t loaded_images < <(podman images --format "{{.Repository}}:{{.Tag}}" | grep "quay\.io/flightctl/flightctl-.*:${TAG}")

          echo "Creating bundle with ${#loaded_images[@]} images:"
          printf '  %s\n' "${loaded_images[@]}"

          podman save --format docker-archive -o flightctl-images-bundle.tar -m "${loaded_images[@]}"

          echo "Bundle created: $(ls -lh flightctl-images-bundle.tar)"
          echo "::endgroup::"

      - name: Upload images bundle
        uses: actions/upload-artifact@v4
        with:
          name: flightctl-images-bundle
          path: flightctl-images-bundle.tar
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

  service-images-manifest:
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-images]
    steps:
      - name: Download image digest artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: digest-*
          path: digests
          merge-multiple: true

      - name: Produce service images manifest
        run: |
          set -euo pipefail
          TAG='${{ needs.compute-tag.outputs.tag }}'
          ARTIFACT_BASE_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts"
          images=(
            flightctl-api
            flightctl-db-setup
            flightctl-worker
            flightctl-periodic
            flightctl-alert-exporter
            flightctl-alertmanager-proxy
            flightctl-cli-artifacts
            flightctl-userinfo-proxy
            flightctl-telemetry-gateway
          )
          printf '{"serviceImages":{' > service-images.json
          first=1
          for img in "${images[@]}"; do
            artifact_name="image-${img#flightctl-}"
            archive_name="${img}-${TAG}.tar"
            digest_file="digests/${img#flightctl-}.txt"
            if [ ! -f "$digest_file" ]; then
              echo "Missing digest file: $digest_file" >&2
              exit 1
            fi
            digest=$(cat "$digest_file")
            if [ $first -eq 0 ]; then printf ',' >> service-images.json; fi
            first=0
            printf '"%s":{"archiveName":"%s","artifactName":"%s","artifactUrl":"%s","digest":"%s"}' "$img" "$archive_name" "$artifact_name" "$ARTIFACT_BASE_URL" "$digest" >> service-images.json
          done
          printf '}}' >> service-images.json
          cat service-images.json

      - name: Upload service images manifest
        uses: actions/upload-artifact@v4
        with:
          name: service-images-manifest
          path: service-images.json
          compression-level: 0
          if-no-files-found: error
          retention-days: 1


  build-helm-charts:
    runs-on: ubuntu-24.04
    needs: [compute-tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Build helm charts
        id: build-charts
        run: |
          set -euo pipefail
          TAG="${{ needs.compute-tag.outputs.helm_tag }}"
          
          echo "::group::Building helm charts"
          helm dependency build ./deploy/helm/flightctl
          helm package ./deploy/helm/flightctl \
            --version "$TAG" \
            --app-version "$TAG"
          echo "::endgroup::"
          
          echo "::group::Computing chart digest"
          CHART_FILE="flightctl-${TAG}.tgz"
          DIGEST=$(sha256sum "$CHART_FILE" | awk '{print $1}')
          echo "sha256:${DIGEST}" > charts-digest.txt
          echo "Chart file: $CHART_FILE"
          echo "Digest: sha256:${DIGEST}"
          echo "::endgroup::"
          
          echo "chart_file=$CHART_FILE" >> "$GITHUB_OUTPUT"
          echo "digest=sha256:${DIGEST}" >> "$GITHUB_OUTPUT"

      - name: Upload helm chart artifact
        uses: actions/upload-artifact@v4
        with:
          name: helm-chart
          path: ${{ steps.build-charts.outputs.chart_file }}
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

      - name: Produce charts manifest
        run: |
          set -euo pipefail
          name="flightctl"
          version="${{ needs.compute-tag.outputs.helm_tag }}"
          artifact_url="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts"
          digest="${{ steps.build-charts.outputs.digest }}"
          chart_file="${{ steps.build-charts.outputs.chart_file }}"
          jq -n \
            --arg n "$name" \
            --arg v "$version" \
            --arg u "$artifact_url" \
            --arg d "$digest" \
            --arg f "$chart_file" \
            '{charts:{($n):{version:$v,artifactUrl:$u,digest:$d,chartFile:$f}}}' > charts.json
          cat charts.json

      - name: Upload charts manifest
        uses: actions/upload-artifact@v4
        with:
          name: charts-manifest
          path: charts.json
          compression-level: 0
          if-no-files-found: error
          retention-days: 1




  build-rpms:
    runs-on: ubuntu-24.04
    needs: [compute-tag]
    strategy:
      matrix:
        include:
          - suffix: el9-x86_64
            root: centos-stream+epel-next-9-x86_64
          - suffix: el10-x86_64
            root: epel-10-x86_64
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Restore Go modules cache
        id: cache-go-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      - name: Restore RPM DNF cache
        id: rpm-dnf-cache-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            bin/rpm-dnf-cache
            bin/rpm-dnf-lib
          key: ${{ runner.os }}-rpm-dnf
          restore-keys: |
            ${{ runner.os }}-rpm-dnf

      - name: Build RPMs (matrix)
        env:
          SOURCE_GIT_TAG: ${{ needs.compute-tag.outputs.git_tag }}
          SOURCE_GIT_TREE_STATE: ${{ needs.compute-tag.outputs.git_tree_state }}
          SOURCE_GIT_COMMIT: ${{ needs.compute-tag.outputs.git_commit }}
          SOURCE_GIT_TAG_NO_V: ${{ needs.compute-tag.outputs.tag }}
        run: |
          set -euo pipefail
          mkdir -p rpms
          echo "::group::Building RPMs for root=${{ matrix.root }}"
          sudo -E ./hack/build_rpms_container.sh --root "${{ matrix.root }}"
          cp -f bin/rpm/*.rpm rpms/ || true
          echo "::endgroup::"

      - name: Upload RPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpms-${{ matrix.suffix }}
          path: rpms/*.rpm
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

      - name: Produce rpms manifest
        run: |
          set -euo pipefail
          out='{"rpms":{"packages":['
          first=1
          for f in rpms/*.rpm; do
            [ -e "$f" ] || continue
            bn=$(basename "$f")
            echo "::group::Processing $bn"
            if [[ "$bn" =~ ^(.+)-([0-9][^-]*)-([^.]*)\.([^.]+)\.rpm$ ]]; then
              name="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"
              release="${BASH_REMATCH[3]}"
              arch="${BASH_REMATCH[4]}"
            else
              # Fallback: best-effort parse
              name="${bn%%-*}"
              rest="${bn#*-}"
              version="${rest%%-*}"
              rest2="${rest#*-}"
              release="${rest2%%.*}"
              arch="${bn##*.}"
              arch="${arch%.rpm}"
            fi
            echo "Name: $name, Version: $version, Release: $release, Arch: $arch"
            url="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts"
            pkg=$(jq -cn --arg n "$name" --arg v "$version" --arg r "$release" --arg a "$arch" --arg u "$url" '{name:$n,version:$v,release:$r,architecture:$a,url:$u}')
            if [ $first -eq 0 ]; then out+="","$pkg"; else out+="$pkg"; fi
            first=0
            echo "::endgroup::"
          done
          out+=']} }'
          printf '%s' "$out" > rpms.json
          cat rpms.json

      - name: Upload rpms manifest
        uses: actions/upload-artifact@v4
        with:
          name: rpms-manifest-${{ matrix.suffix }}
          path: rpms.json
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

      - name: Save Go modules cache
        if: ${{ always() }}
        uses: actions/cache/save@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      - name: Save RPM DNF cache
        uses: actions/cache/save@v4
        with:
          path: |
            bin/rpm-dnf-cache
            bin/rpm-dnf-lib
          key: ${{ runner.os }}-rpm-dnf

  # =============================================================================
  # AGENT IMAGES BUILD FLOW
  # =============================================================================
  # Agent images are built in multiple stages:
  # 1. Prebase image: Base OS with flightctl dependencies (no RPMs yet)
  # 2. Base image: Prebase + flightctl RPMs installed
  # 3. Variants: Multiple specialized images built from base (podman/non-podman, various configs)
  # 4. QCOW2: Virtual machine disk image created from base image
  # 
  # Traditional flow (multi-job):
  #   build-rpms → build-agent-prebase-image → build-agent-base-image → ┬→ build-agent-variants
  #                                                                      └→ build-qcow2
  # 
  # New unified flow (single job):
  #   build-agent-images-unified: Fetches RPMs, builds prebase, builds base,
  #                               then runs variants+qcow2 in parallel
  # =============================================================================

  build-agent-prebase-image:
    if: false  # Skipped in favor of build-agent-images-unified
    runs-on: ubuntu-24.04
    needs: [compute-tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Restore DNF cache
        id: prebase-cache-dnf-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            /var/cache/dnf
            /var/lib/dnf
          key: ${{ runner.os }}-dnf-e2e
          restore-keys: |
            ${{ runner.os }}-dnf-

      # Removed root permission tweaks; prebase build runs rootless

      - name: Restore bootc-image-builder cache
        id: prebase-cache-bootc-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            bin/dnf-cache
            bin/osbuild-cache
            dnf-cache
            osbuild-cache
          key: ${{ runner.os }}-bootc-cache-e2e-${{ hashFiles('test/scripts/agent-images-v2/Containerfile-prebase') }}
          restore-keys: |
            ${{ runner.os }}-bootc-cache-e2e-

      - name: Build prebase agent image
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE_REPO: quay.io/flightctl/flightctl-device
          SOURCE_GIT_TAG: ${{ needs.compute-tag.outputs.git_tag }}
          SOURCE_GIT_TREE_STATE: ${{ needs.compute-tag.outputs.git_tree_state }}
          SOURCE_GIT_COMMIT: ${{ needs.compute-tag.outputs.git_commit }}
        run: |
          set -euo pipefail
          ./test/scripts/agent-images-v2/build_agent_images.sh --mode prebase

      - name: Save prebase image as artifact
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE_REPO: quay.io/flightctl/flightctl-device
        run: |
          set -euo pipefail
          podman save -o agent-image-prebase.tar "${IMAGE_REPO}:prebase-${TAG}" "${IMAGE_REPO}:prebase"

      - name: Upload prebase image artifact
        uses: actions/upload-artifact@v4
        with:
          name: agent-image-prebase
          path: agent-image-prebase.tar
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

      - name: Save caches
        uses: actions/cache/save@v4
        with:
          path: |
            bin/dnf-cache
            bin/osbuild-cache
            dnf-cache
            osbuild-cache
          key: ${{ runner.os }}-bootc-cache-e2e-${{ hashFiles('test/scripts/agent-images-v2/Containerfile-prebase') }}

      - name: Produce rpms manifest
        run: |
          set -euo pipefail
          out='{"rpms":{"packages":['
          first=1
          for f in bin/rpm/*.rpm; do
            [ -e "$f" ] || continue
            bn=$(basename "$f")
            echo "::group::Processing $bn"
            if [[ "$bn" =~ ^(.+)-([0-9][^-]*)-([^.]*)\.([^.]+)\.rpm$ ]]; then
              name="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"
              release="${BASH_REMATCH[3]}"
              arch="${BASH_REMATCH[4]}"
            else
              # Fallback: best-effort parse
              name="${bn%%-*}"
              rest="${bn#*-}"
              version="${rest%%-*}"
              rest2="${rest#*-}"
              release="${rest2%%.*}"
              arch="${bn##*.}"
              arch="${arch%.rpm}"
            fi
            echo "Name: $name, Version: $version, Release: $release, Arch: $arch"
            url="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts"
            pkg=$(jq -cn --arg n "$name" --arg v "$version" --arg r "$release" --arg a "$arch" --arg u "$url" '{name:$n,version:$v,release:$r,architecture:$a,url:$u}')
            if [ $first -eq 0 ]; then out+="","$pkg"; else out+="$pkg"; fi
            first=0
            echo "::endgroup::"
          done
          out+=']} }'
          printf '%s' "$out" > rpms.json
          cat rpms.json

      - name: Upload rpms manifest
        uses: actions/upload-artifact@v4
        with:
          name: rpms-manifest
          path: rpms.json
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

  build-agent-base-image:
    if: false  # Skipped in favor of build-agent-images-unified
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-rpms, build-agent-prebase-image]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Restore DNF cache
        id: cache-dnf-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            /var/cache/dnf
            /var/lib/dnf
          key: ${{ runner.os }}-dnf-e2e
          restore-keys: |
            ${{ runner.os }}-dnf-

      # Removed root permission tweaks; base build runs rootless

      - name: Restore bootc-image-builder cache
        id: cache-bootc-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            bin/dnf-cache
            bin/osbuild-cache
            dnf-cache
            osbuild-cache
          key: ${{ runner.os }}-bootc-cache-e2e-${{ hashFiles('test/scripts/agent-images-v2/Containerfile-base') }}
          restore-keys: |
            ${{ runner.os }}-bootc-cache-e2e-

      - name: Load prebase image using artifact loader script
        env:
          RUN_ID: ${{ github.run_id }}
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Loading prebase image artifact..."
          ./hack/load-github-artifact.sh agent-image-prebase "$RUN_ID" "$REPO"

      - name: Download RPM artifacts
        uses: actions/download-artifact@v4
        with:
          name: rpms-${{ github.sha }}
          path: rpms

      - name: Build base agent image
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE_REPO: quay.io/flightctl/flightctl-device
          PREBASE_IMAGE: quay.io/flightctl/flightctl-device:prebase-${{ needs.compute-tag.outputs.tag }}
          SOURCE_GIT_TAG: ${{ needs.compute-tag.outputs.git_tag }}
          SOURCE_GIT_TREE_STATE: ${{ needs.compute-tag.outputs.git_tree_state }}
          SOURCE_GIT_COMMIT: ${{ needs.compute-tag.outputs.git_commit }}
        run: |
          set -euo pipefail
          ./test/scripts/agent-images-v2/build_agent_images.sh --mode base

      - name: Save base image as artifact
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE_REPO: quay.io/flightctl/flightctl-device
        run: |
          set -euo pipefail
          podman save -o agent-image-base.tar "${IMAGE_REPO}:base-${TAG}" "${IMAGE_REPO}:base"

      - name: Upload base image artifact
        uses: actions/upload-artifact@v4
        with:
          name: agent-image-base
          path: agent-image-base.tar
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

      - name: Save caches
        uses: actions/cache/save@v4
        with:
          path: |
            bin/dnf-cache
            bin/osbuild-cache
            dnf-cache
            osbuild-cache
          key: ${{ runner.os }}-bootc-cache-e2e-${{ hashFiles('test/scripts/agent-images-v2/Containerfile-base') }}

  build-agent-variants:
    if: false  # Skipped in favor of build-agent-images-unified
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-agent-base-image]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Load base image using artifact loader script
        env:
          RUN_ID: ${{ github.run_id }}
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Loading base image artifact..."
          ./hack/load-github-artifact.sh agent-image-base "$RUN_ID" "$REPO"

      - name: Build variant images
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE_REPO: quay.io/flightctl/flightctl-device
          PARALLEL_JOBS: 10
        run: |
          set -euo pipefail
          ./test/scripts/agent-images-v2/build_agent_images.sh --mode variants

      - name: Create agent images bundle
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
        run: |
          set -euo pipefail
          echo "::group::Creating agent images bundle (base + variants) with dual tags"
          # Collect all flightctl-device images (both versioned and plain tags), excluding prebase
          mapfile -t all_images < <(podman images --format "{{.Repository}}:{{.Tag}}" | grep "quay\.io/flightctl/flightctl-device:" | grep -v ":prebase")
          echo "Found ${#all_images[@]} agent images (base + variants with all tags):"
          printf '  %s\n' "${all_images[@]}"
          podman save --format docker-archive -o agent-images-bundle.tar -m "${all_images[@]}"
          echo "::endgroup::"

      - name: Upload agent images bundle
        uses: actions/upload-artifact@v4
        with:
          name: agent-images-bundle
          path: agent-images-bundle.tar
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

  build-sleep-app-images:
    runs-on: ubuntu-24.04
    needs: [compute-tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Build sleep app images
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          SLEEP_APP_REPO: quay.io/flightctl/sleep-app
          PARALLEL_JOBS: 4
          SOURCE_GIT_TAG: ${{ needs.compute-tag.outputs.git_tag }}
          SOURCE_GIT_TREE_STATE: ${{ needs.compute-tag.outputs.git_tree_state }}
          SOURCE_GIT_COMMIT: ${{ needs.compute-tag.outputs.git_commit }}
        run: |
          set -euo pipefail
          ./test/scripts/agent-images-v2/build_agent_images.sh --mode sleep-apps

      - name: Create sleep app bundle
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
        run: |
          set -euo pipefail
          echo "::group::Creating sleep app images bundle with dual tags"
          # Collect all sleep-app images (both versioned and plain tags)
          mapfile -t all_sleep_images < <(podman images --format "{{.Repository}}:{{.Tag}}" | grep "quay\.io/flightctl/sleep-app:")
          echo "Found ${#all_sleep_images[@]} sleep app images (all tags):"
          printf '  %s\n' "${all_sleep_images[@]}"
          podman save --format docker-archive -o sleep-app-images-bundle.tar -m "${all_sleep_images[@]}"
          echo "::endgroup::"

      - name: Upload sleep app bundle
        uses: actions/upload-artifact@v4
        with:
          name: sleep-app-images-bundle
          path: sleep-app-images-bundle.tar
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

  build-qcow2:
    if: false  # Skipped in favor of build-agent-images-unified
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-agent-base-image]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
      - name: Load base image using artifact loader script
        env:
          RUN_ID: ${{ github.run_id }}
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Loading base image artifact..."
          sudo -E ./hack/load-github-artifact.sh agent-image-base "$RUN_ID" "$REPO"

      - name: Restore bootc-image-builder cache
        id: cache-bootc-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            bin/dnf-cache
            bin/osbuild-cache
            dnf-cache
            osbuild-cache
          key: ${{ runner.os }}-bootc-cache-e2e-${{ hashFiles('test/scripts/agent-images-v2/Containerfile-base') }}
          restore-keys: |
            ${{ runner.os }}-bootc-cache-e2e-

      - name: Build qcow2 image
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE_REPO: quay.io/flightctl/flightctl-device
        run: |
          set -euo pipefail
          sudo -E ./test/scripts/agent-images-v2/build_agent_images.sh --mode qcow2
          sudo chown -R runner:runner output/

      - name: Upload qcow2 image
        uses: actions/upload-artifact@v4
        with:
          name: agent-qcow2-image
          path: output/qcow2/disk.qcow2
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

      - name: Save caches
        uses: actions/cache/save@v4
        with:
          path: |
            bin/dnf-cache
            bin/osbuild-cache
            dnf-cache
            osbuild-cache
          key: ${{ runner.os }}-bootc-cache-e2e-${{ hashFiles('test/scripts/agent-images-v2/Containerfile-base') }}

  build-agent-images-unified:
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-rpms]
    strategy:
      matrix:
        include:
          - os_id: cs9
            rpm_suffix: el9-x86_64
          - os_id: cs10
            rpm_suffix: el10-x86_64
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Restore DNF cache
        id: cache-dnf-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            /var/cache/dnf
            /var/lib/dnf
          key: ${{ runner.os }}-dnf-e2e
          restore-keys: |
            ${{ runner.os }}-dnf-

      - name: Restore bootc-image-builder cache
        id: cache-bootc-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            bin/dnf-cache
            bin/osbuild-cache
            dnf-cache
            osbuild-cache
          key: ${{ runner.os }}-bootc-cache-e2e-unified-${{ hashFiles('test/scripts/agent-images-v2/base/Containerfile') }}
          restore-keys: |
            ${{ runner.os }}-bootc-cache-e2e-

      - name: Download RPM artifacts
        uses: actions/download-artifact@v4
        with:
          name: rpms-${{ matrix.rpm_suffix }}
          path: rpms
      - name: Build agent images for flavor
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE_REPO: quay.io/flightctl/flightctl-device
          SOURCE_GIT_TAG: ${{ needs.compute-tag.outputs.git_tag }}
          SOURCE_GIT_TREE_STATE: ${{ needs.compute-tag.outputs.git_tree_state }}
          SOURCE_GIT_COMMIT: ${{ needs.compute-tag.outputs.git_commit }}
          FLAVORS: ${{ matrix.os_id }}
        run: |
          set -euo pipefail
          echo "::group::Building base for flavor ${FLAVORS}"
          sudo -E ./test/scripts/agent-images-v2/scripts/build.sh --base-only
          echo "::endgroup::"

      - name: Build variants+bundle and qcow2 in parallel (per flavor)
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE_REPO: quay.io/flightctl/flightctl-device
          OS_ID: ${{ matrix.os_id }}
        run: |
          set -euo pipefail
          sudo -E ./test/scripts/agent-images-v2/scripts/build_and_qcow2.sh --os-id "${OS_ID}"

      - name: Print parallel build logs (per flavor)
        if: always()
        env:
          OS_ID: ${{ matrix.os_id }}
        run: |
          set -euo pipefail
          LOG_DIR="artifacts/logs-${OS_ID}"
          echo "::group::Variants+bundle output"
          if [ -f "${LOG_DIR}/variants.log" ]; then
            cat "${LOG_DIR}/variants.log"
          else
            echo "No variants.log found at ${LOG_DIR}/variants.log"
          fi
          echo "::endgroup::"
          echo "::group::QCOW2 output"
          if [ -f "${LOG_DIR}/qcow2.log" ]; then
            cat "${LOG_DIR}/qcow2.log"
          else
            echo "No qcow2.log found at ${LOG_DIR}/qcow2.log"
          fi
          echo "::endgroup::"

      - name: Upload agent images bundle (per flavor)
        uses: actions/upload-artifact@v4
        with:
          name: agent-images-bundle-${{ matrix.os_id }}
          path: artifacts/agent-images-bundle-${{ matrix.os_id }}.tar
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

      - name: Upload qcow2 image (per flavor)
        uses: actions/upload-artifact@v4
        with:
          name: agent-qcow2-image-${{ matrix.os_id }}
          path: artifacts/agent-qcow2-${{ matrix.os_id }}/qcow2/disk.qcow2
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

      - name: Save caches
        uses: actions/cache/save@v4
        with:
          path: |
            bin/dnf-cache
            bin/osbuild-cache
            dnf-cache
            osbuild-cache
          key: ${{ runner.os }}-bootc-cache-e2e-unified-${{ hashFiles('test/scripts/agent-images-v2/base/Containerfile') }}

 

  build-flightctl-cli:
    name: Build Flightctl CLI Binaries
    needs: [compute-tag]
    strategy:
      matrix:
        tag: [ "linux-amd64" ]
        # tag: [ "linux-amd64", "linux-arm64", "darwin-amd64", "darwin-arm64", "windows-amd64", "windows-arm64" ]
        include:
          # Linux builds
          - tag: linux-amd64
            arch: amd64
            os: linux
            zip: .tar.gz
            ext: ""
          # - tag: linux-arm64
          #   arch: arm64
          #   os: linux
          #   zip: .tar.gz
          #   ext: ""
          # # macOS builds
          # - tag: darwin-amd64
          #   arch: amd64
          #   os: darwin
          #   zip: .zip
          #   ext: ""
          # - tag: darwin-arm64
          #   arch: arm64
          #   os: darwin
          #   zip: .zip
          #   ext: ""
          # # Windows builds
          # - tag: windows-amd64
          #   arch: amd64
          #   os: windows
          #   zip: .zip
          #   ext: .exe
          # - tag: windows-arm64
          #   arch: arm64
          #   os: windows
          #   zip: .zip
          #   ext: .exe

    runs-on: ubuntu-24.04
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      # Install dependencies
      - name: Install Dependencies
        run: go mod tidy

      - name: Build
        run: |
          DISABLE_FIPS="true" GOOS="${{ matrix.os }}" GOARCH="${{ matrix.arch }}" make build-cli
          mv "bin/flightctl${{ matrix.ext }}" "flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}"
          
          echo "::group::Computing checksum and creating archive"
          SHA=$(shasum -a 256 flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }} | cut -d' ' -f1)
          echo ${SHA} > flightctl-${{ matrix.os }}-${{ matrix.arch}}-sha256.txt
          echo "SHA256: ${SHA}"
          
          if [ "${{ matrix.zip }}" = ".zip" ]; then
            zip flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.zip }} flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}
          else
            tar cvf flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.zip }} flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}
          fi
          echo "::endgroup::"

      - name: Save zip
        uses: actions/upload-artifact@v4
        with:
          name: flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.zip }}
          path: flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.zip }}

      - name: Save binary
        uses: actions/upload-artifact@v4
        with:
          name: flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}
          path: flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}

      - name: Save checksum
        uses: actions/upload-artifact@v4
        with:
          path: flightctl-${{ matrix.os }}-${{ matrix.arch}}-sha256.txt
          name: flightctl-${{ matrix.os }}-${{ matrix.arch}}-sha256.txt

  artifacts-ready:
    runs-on: ubuntu-24.04
    needs: [compute-tag, service-images-manifest, build-rpms, build-helm-charts, build-flightctl-cli, build-agent-images-unified]
    if: ${{ !cancelled() && needs.compute-tag.result == 'success' && needs.service-images-manifest.result == 'success' && needs.build-rpms.result == 'success' && needs.build-helm-charts.result == 'success' && needs.build-flightctl-cli.result == 'success' && needs.build-agent-images-unified.result == 'success' }}
    steps:
      - name: Download service images manifest
        uses: actions/download-artifact@v4
        with:
          name: service-images-manifest
          path: manifests

      - name: Download charts manifest
        uses: actions/download-artifact@v4
        with:
          name: charts-manifest
          path: manifests

      - name: Download rpms manifests
        uses: actions/download-artifact@v4
        with:
          pattern: "rpms-manifest-*"
          path: manifests
          merge-multiple: true

      - name: Assemble final build manifest
        run: |
          set -euo pipefail
          ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          meta=$(jq -n --arg bid "github-run-${GITHUB_RUN_ID}" --arg sha "${GITHUB_SHA}" --arg ts "$ts" '{buildId:$bid,commitSha:$sha,timestamp:$ts}')
          parts="{}"
          for f in manifests/*.json; do
            [ -e "$f" ] || continue
            parts=$(jq -s 'reduce .[] as $i ({}; . * $i)' <(echo "$parts") "$f")
          done
          jq -s '.[0] * .[1]' <(echo "$meta") <(echo "$parts") > build-manifest.json
          cat build-manifest.json

      - name: Upload build manifest
        uses: actions/upload-artifact@v4
        with:
          name: build-manifest
          path: build-manifest.json
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

      - name: Download image manifests for summary
        uses: actions/download-artifact@v4
        with:
          name: service-images-manifest
          path: summary-manifests

      - name: Generate step summary
        run: |
          TAG='${{ needs.compute-tag.outputs.helm_tag }}'
          RUN_ID='${{ github.run_id }}'
          CHART_FILE="flightctl-${TAG}.tgz"
          ARTIFACTS_URL="https://github.com/${{ github.repository }}/actions/runs/${RUN_ID}#artifacts"

          echo "## :black_small_square: Build Artifacts Ready" > $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`${TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "**CLI Binaries** and **RPMs** are ready!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "<details>" >> $GITHUB_STEP_SUMMARY
          echo "<summary><strong>CLI Binaries</strong></summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Download CLI for your platform" >> $GITHUB_STEP_SUMMARY
          echo "gh run download ${RUN_ID} -n flightctl-linux-amd64      # Linux x64" >> $GITHUB_STEP_SUMMARY
          echo "gh run download ${RUN_ID} -n flightctl-linux-arm64      # Linux ARM64" >> $GITHUB_STEP_SUMMARY
          echo "gh run download ${RUN_ID} -n flightctl-darwin-amd64     # macOS x64" >> $GITHUB_STEP_SUMMARY
          echo "gh run download ${RUN_ID} -n flightctl-darwin-arm64     # macOS ARM64" >> $GITHUB_STEP_SUMMARY
          echo "gh run download ${RUN_ID} -n flightctl-windows-amd64.exe  # Windows x64" >> $GITHUB_STEP_SUMMARY
          echo "gh run download ${RUN_ID} -n flightctl-windows-arm64.exe  # Windows ARM64" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### RPM Packages" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Download RPM packages" >> $GITHUB_STEP_SUMMARY
          echo "gh run download ${RUN_ID} -n rpms-${{ github.sha }}  # Packages for RHEL/Fedora" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  services-ready:
    runs-on: ubuntu-24.04
    needs: [compute-tag, bundle-images, build-helm-charts]
    if: ${{ !cancelled() && needs.compute-tag.result == 'success' && needs.bundle-images.result == 'success' && needs.build-helm-charts.result == 'success' }}
    steps:
      - name: Services artifacts ready
        run: |
          echo "Backend services and Helm chart are ready for deployment"
          echo "Helm chart: helm-chart"

      - name: Generate services summary
        run: |
          IMAGE_TAG='${{ needs.compute-tag.outputs.tag }}'
          HELM_TAG='${{ needs.compute-tag.outputs.helm_tag }}'
          RUN_ID='${{ github.run_id }}'
          CHART_FILE="helm-chart/flightctl-${HELM_TAG}.tgz"
          ARTIFACTS_URL="https://github.com/${{ github.repository }}/actions/runs/${RUN_ID}#artifacts"

          echo "## :gear: Services Ready for Deployment" > $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`${IMAGE_TAG}\` | [All artifacts](${ARTIFACTS_URL})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "**Container Images** and **Helm Chart** are ready!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # List container images in collapsible section
          echo "<details>" >> $GITHUB_STEP_SUMMARY
          echo "<summary><strong>Container Images (9)</strong></summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- \`quay.io/flightctl/flightctl-api:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`quay.io/flightctl/flightctl-periodic:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`quay.io/flightctl/flightctl-worker:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`quay.io/flightctl/flightctl-cli-artifacts:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`quay.io/flightctl/flightctl-alert-exporter:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`quay.io/flightctl/flightctl-alertmanager-proxy:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`quay.io/flightctl/flightctl-userinfo-proxy:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`quay.io/flightctl/flightctl-db-setup:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`quay.io/flightctl/flightctl-telemetry-gateway:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### :rocket: Deployment" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Download deployment artifacts" >> $GITHUB_STEP_SUMMARY
          echo "gh run download ${RUN_ID} -n helm-chart -n flightctl-images-bundle" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Load service images into kind" >> $GITHUB_STEP_SUMMARY
          echo "kind load image-archive flightctl-images-bundle/flightctl-images-bundle.tar" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Install with Helm (parameterize with --set as needed)" >> $GITHUB_STEP_SUMMARY
          echo "helm upgrade --install flightctl ${CHART_FILE}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Or with a script:" >> $GITHUB_STEP_SUMMARY
          echo "./test/scripts/deploy_with_helm.sh --chart-path=\"${CHART_FILE}\" --image-registry=\"quay.io/flightctl/\" --image-tag=\"${IMAGE_TAG}\"" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  test-artifacts-ready:
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-agent-images-unified]
    if: ${{ !cancelled() && needs.compute-tag.result == 'success' && needs.build-agent-images-unified.result == 'success' }}
    steps:
      - name: Generate test artifacts summary
        run: |
          TAG='${{ needs.compute-tag.outputs.tag }}'
          RUN_ID='${{ github.run_id }}'
          ARTIFACTS_URL="https://github.com/${{ github.repository }}/actions/runs/${RUN_ID}#artifacts"
          
          echo "## :test_tube: Test Artifacts Ready" > $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`${TAG}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "**Test Images**" >> $GITHUB_STEP_SUMMARY
          echo "- :black_small_square: \`agent-images-bundle\` - Agent and sleep app container images for testing" >> $GITHUB_STEP_SUMMARY
          echo "- :black_small_square: \`agent-qcow2-image\` - QCOW2 disk image for VM testing" >> $GITHUB_STEP_SUMMARY

##################
### SMOKE TEST ###
##################
  smoke:
    runs-on: ubuntu-24.04
    needs: [compute-tag, bundle-images, build-helm-charts, build-flightctl-cli, build-auxiliary-images]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
     
      - name: Download backend images
        uses: actions/download-artifact@v4
        with:
          name: flightctl-images-bundle

      - name: Download Helm chart
        uses: actions/download-artifact@v4
        with:
          name: helm-chart

      - name: Download Linux CLI binary
        uses: actions/download-artifact@v4
        with:
          name: flightctl-linux-amd64
          path: .

      - name: Setup CLI binary
        run: |
          mkdir -p bin
          mv flightctl-linux-amd64 bin/flightctl
          chmod +x bin/flightctl

      - name: List files
        run: ls -la

      - name: Create cluster
        run: make cluster

      - name: Load images into kind
        run: |
          set -euo pipefail
          echo "Loading flightctl images bundle into kind cluster..."
          kind load image-archive flightctl-images-bundle.tar
          echo "Images loaded successfully"

      - name: Deploy FlightCtl with packaged chart
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
        run: |
          set -euo pipefail
          CHART_FILE="flightctl-${{ needs.compute-tag.outputs.helm_tag }}.tgz"

          echo "Chart file: ${CHART_FILE}"
          echo "Image registry: quay.io/flightctl/"
          echo "Image tag: ${TAG}"

          ./test/scripts/deploy_with_helm.sh \
            --chart-path="${CHART_FILE}" \
            --image-registry="quay.io/flightctl/" \
            --image-tag="${TAG}"

      - name: Prepare agent config
        run: ./test/scripts/agent-images/prepare_agent_config.sh --status-update-interval 0m2s --spec-fetch-interval 0m2s

      - name: Check
        run: |
          kubectl get pods --all-namespaces

      - name: Apply device
        run: bin/flightctl apply -f examples/device.yaml

      - name: Apply fleet
        run: bin/flightctl apply -f examples/fleet.yaml

      - name: Apply enrollmentrequest
        run: bin/flightctl apply -f examples/enrollmentrequest.yaml

      - name: Apply repository
        run: bin/flightctl apply -f examples/repository-flightctl.yaml

      - name: Apply resourcesync
        run: bin/flightctl apply -f examples/resourcesync.yaml

      - name: Build the simulator
        run: DISABLE_FIPS="true" make build-devicesimulator

      - name: Simulator run
        run: bin/devicesimulator --config bin/agent/etc/flightctl/config.yaml --count 1 --stop-after 1m

      - name: Collect and Upload Logs
        if: always()
        uses: ./.github/actions/collect-logs
        with:
          namespace-external: 'flightctl-external'
          namespace-internal: 'flightctl-internal'
          log-directory: 'smoke-logs'

  e2e-tests:
    runs-on: ubuntu-24.04
    needs: [compute-tag, bundle-images, build-helm-charts, build-flightctl-cli, build-agent-images-unified, build-sleep-app-images, build-auxiliary-images]
    strategy:
      fail-fast: false
      matrix:
        os_id: [cs9, cs10]
        ginkgo_node: [1,2,3,4,5,6,7,8]
    steps:
      # ========== PREPARE ENVIRONMENT ==========
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Free disk space
        run: |
          sudo rm -rf /usr/local/lib/android >/dev/null 2>&1 &
          echo "Started background removal of /usr/local/lib/android (PID: $!)"
          df -h

      - name: Start disk space monitoring
        run: |
          cat > /tmp/disk_monitor.sh << 'EOF'
          #!/bin/bash
          prev_percent=0

          # Cleanup function
          cleanup() {
            echo "Disk monitoring stopped"
            exit 0
          }

          # Handle termination signals
          trap cleanup TERM INT EXIT

          while [ ! -f /tmp/stop_disk_monitor ]; do
            usage=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
            echo "$usage" > /tmp/disk_usage_percent.txt

            if [ "$usage" -gt 90 ] && [ "$usage" -gt "$prev_percent" ]; then
              echo "::warning::Disk usage is at ${usage}% and growing"
              prev_percent=$usage
            fi

            sleep 1
          done

          cleanup
          EOF
          chmod +x /tmp/disk_monitor.sh
          /tmp/disk_monitor.sh &
          MONITOR_PID=$!
          echo "MONITOR_PID=$MONITOR_PID" >> $GITHUB_ENV
          echo "Disk monitoring started in background (PID: $MONITOR_PID)"

      # ========== SETUP DEPENDENCIES ==========
      - name: Setup dependencies (KVM, libvirt, etc)
        uses: ./.github/actions/setup-dependencies
        with:
          setup_kvm: yes

      # ========== DOWNLOAD ALL ARTIFACTS ==========
      - name: Download required test artifacts (one step)
        uses: actions/download-artifact@v4
        with:
          pattern: "{flightctl-images-bundle,helm-chart,flightctl-linux-amd64,auxiliary-image-git-server,agent-images-bundle-${{ matrix.os_id }},sleep-app-images-bundle,agent-qcow2-image-${{ matrix.os_id }}}"
          path: artifacts
          merge-multiple: true

      - name: Normalize agent images bundle name
        run: |
          set -euo pipefail
          src="artifacts/agent-images-bundle-${{ matrix.os_id }}.tar"
          if [ -f "${src}" ]; then
            mv -f "${src}" artifacts/agent-images-bundle.tar
          fi

      - name: Normalize qcow2 path for downstream steps
        run: |
          set -euo pipefail
          mkdir -p bin/output/qcow2
          src=""
          if [ -f artifacts/output/qcow2/disk.qcow2 ]; then
            src="artifacts/output/qcow2/disk.qcow2"
          elif [ -f artifacts/disk.qcow2 ]; then
            src="artifacts/disk.qcow2"
          else
            src=$(find artifacts -maxdepth 3 -type f -name 'disk.qcow2' | head -n1 || true)
          fi
          if [ -z "${src}" ]; then
            echo "disk.qcow2 not found in artifacts" >&2
            exit 1
          fi
          mv -f "${src}" bin/output/qcow2/disk.qcow2

      - name: Setup CLI binary
        run: |
          set -euo pipefail
          mkdir -p bin
          mv artifacts/flightctl-linux-amd64 bin/flightctl
          chmod +x bin/flightctl
          echo "CLI binary ready at bin/flightctl"

      # ========== INITIALIZE KIND CLUSTER ==========
      - name: Create kind cluster
        run: make cluster

      # ========== LOAD IMAGES INTO KIND ==========
      - name: Load backend images into kind
        run: |
          set -euo pipefail
          echo "Loading backend service images into kind"
          kind load image-archive artifacts/flightctl-images-bundle.tar
          echo "Backend images loaded successfully"

      - name: Load git-server image into kind
        run: |
          set -euo pipefail
          echo "Loading git-server image into kind"
          kind load image-archive artifacts/auxiliary-image-git-server.tar
          echo "Git-server image loaded successfully"

      # Assume skopeo and jq are available on the runner; avoid sudo outside qcow job

      - name: Clean up image bundle files
        run: |
          set -euo pipefail
          echo "::group::Cleaning up image bundle files"
          echo "Removing backend and auxiliary image bundles (no longer needed after loading into kind)..."
          rm -f artifacts/flightctl-images-bundle.tar
          rm -f artifacts/auxiliary-image-git-server.tar
          echo "Kept agent-images-bundle.tar and sleep-app-images-bundle.tar (needed for E2E registry push)"
          df -h
          echo "::endgroup::"

      # ========== DEPLOY BACKEND WITH HELM ==========
      - name: Deploy FlightCtl backend with packaged chart
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
        run: |
          set -euo pipefail
          CHART_FILE="artifacts/flightctl-${{ needs.compute-tag.outputs.helm_tag }}.tgz"

          echo "::group::Deploying FlightCtl backend services"
          echo "Chart file: ${CHART_FILE}"
          echo "Image registry: quay.io/flightctl/"
          echo "Image tag: ${TAG}"
          
          ./test/scripts/deploy_with_helm.sh \
            --chart-path="${CHART_FILE}" \
            --image-registry="quay.io/flightctl/" \
            --image-tag="${TAG}"
          echo "::endgroup::"

      # ========== SETUP E2E ENVIRONMENT ==========
      - name: Create E2E certificates and SSH keys
        run: |
          set -euo pipefail
          ./test/scripts/create_e2e_certs.sh

      - name: Deploy E2E extras (registry, git-server)
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
        run: |
          set -euo pipefail
          export GITSERVER_IMAGE="quay.io/flightctl-tests/git-server:${TAG}"
          ./test/scripts/deploy_e2e_extras_with_helm.sh

      - name: Push agent and sleep app images to E2E registry
        run: |
          set -euo pipefail
          echo "::group::Pushing agent and sleep app images to E2E registry"
          
          # Verify required files exist
          if [ ! -f artifacts/agent-images-bundle.tar ]; then
            echo "::error::artifacts/agent-images-bundle.tar not found"
            exit 1
          fi
          if [ ! -f artifacts/sleep-app-images-bundle.tar ]; then
            echo "::error::artifacts/sleep-app-images-bundle.tar not found"
            exit 1
          fi
          
          source ./test/scripts/functions
          export REGISTRY_ENDPOINT="$(registry_address)"
          echo "Using REGISTRY_ENDPOINT=${REGISTRY_ENDPOINT}"
          
          echo "Pushing agent images bundle..."
          ./test/scripts/agent-images-v2/upload-images.sh artifacts/agent-images-bundle.tar --insecure --jobs 2
          agent_exit=$?
          if [ $agent_exit -ne 0 ]; then
            echo "::error::Failed to push agent images (exit code: $agent_exit)"
            exit $agent_exit
          fi
          
          echo "Pushing sleep app images bundle..."
          ./test/scripts/agent-images-v2/upload-images.sh artifacts/sleep-app-images-bundle.tar --insecure --jobs 2
          sleep_exit=$?
          if [ $sleep_exit -ne 0 ]; then
            echo "::error::Failed to push sleep app images (exit code: $sleep_exit)"
            exit $sleep_exit
          fi
          
          echo "Successfully pushed all images to registry"
          echo "::endgroup::"

      - name: Clean up agent and sleep app bundles
        run: |
          set -euo pipefail
          echo "::group::Cleaning up agent and sleep app bundle files"
          echo "Removing agent and sleep app bundles (no longer needed after push to E2E registry)..."
          rm -f artifacts/agent-images-bundle.tar
          rm -f artifacts/sleep-app-images-bundle.tar
          echo "All bundle files cleaned up"
          df -h
          echo "::endgroup::"

      - name: Prune Podman images (post-push)
        run: |
          set -euo pipefail
          echo "::group::Pruning Podman images to free space"
          podman image prune -af
          podman system df || true
          df -h
          echo "::endgroup::"

      - name: Prepare agent configuration
        run: |
          set -euo pipefail
          ./test/scripts/agent-images-v2/prepare_agent_config.sh --status-update-interval 0m2s --spec-fetch-interval 0m2s

      - name: Inject agent files into qcow2
        run: |
          set -euo pipefail
          echo "::group::Injecting agent config and certs into qcow2"
          source ./test/scripts/functions
          ADDR="$(registry_address)"
          bash ./test/scripts/inject_agent_files_into_qcow.sh \
            --qcow bin/output/qcow2/disk.qcow2 \
            --agent-dir bin/agent/etc/flightctl \
            --mount-dir /mnt/qcow \
            --registry-addr "$ADDR" \
            --e2e-ca bin/e2e-certs/pki/CA/ca.crt
          echo "::endgroup::"

      - name: Setup E2E test environment
        run: |
          set -euo pipefail
          ./test/scripts/setup_e2e_environment.sh
          df -h
      # ========== RUN E2E TESTS ==========
      - name: Run E2E tests (agent tests only)
        run: |
          set -euo pipefail
          source ./test/scripts/functions
          export REGISTRY_ENDPOINT=$(registry_address)
          make run-e2e-test VERBOSE=true
        env:
          GINKGO_LABEL_FILTER: 'sanity'
          GINKGO_TOTAL_NODES: ${{ env.GINKGO_TOTAL_NODES }}
          GINKGO_NODE: ${{ matrix.ginkgo_node }}

      - name: Collect and Upload Logs
        if: always()
        uses: ./.github/actions/collect-logs
        with:
          namespace-external: 'flightctl-external'
          namespace-internal: 'flightctl-internal'
          log-directory: 'e2e-logs-node-${{ matrix.ginkgo_node }}'

      - name: Stop disk space monitoring
        if: always()
        run: |
          echo "Stopping disk monitoring..."
          touch /tmp/stop_disk_monitor
          if [ -n "${MONITOR_PID:-}" ]; then
            kill $MONITOR_PID 2>/dev/null || true
          fi
          echo "Disk monitoring stopped"
          df -h

  e2e-test:
    runs-on: ubuntu-latest
    needs: e2e-tests
    if: always()
    steps:
      - name: Check E2E Test Results
        run: |
          if [[ "${{ needs.e2e-tests.result }}" == "success" ]]; then
            echo "All E2E tests passed!"
            exit 0
          elif [[ "${{ needs.e2e-tests.result }}" == "skipped" ]]; then
            echo "E2E tests were skipped"
            exit 0
          else
            echo "E2E tests failed or were cancelled"
            exit 1
          fi




























