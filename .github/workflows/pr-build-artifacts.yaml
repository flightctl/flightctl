name: "PR Build Artifacts"
permissions:
  pull-requests: write
  issues: write
on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      expires_after:
        description: "TTL for images label quay.expires-after (empty = no TTL)"
        required: false
        default: "8h"
        type: string

env:
  # Enable BuildKit for cache mounts
  DOCKER_BUILDKIT: 1
  BUILDKIT_PROGRESS: plain
  GITHUB_ACTIONS: true

jobs:
  compute-tag:
    runs-on: ubuntu-24.04
    outputs:
      tag: ${{ steps.compute-tag.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Compute tag
        id: compute-tag
        run: |
          set -euo pipefail
          TAG=$(./hack/current-version)
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Computed tag: $TAG"

      - name: Post initial PR comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const tag = '${{ steps.compute-tag.outputs.tag }}';
            const runId = '${{ github.run_id }}';
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;
            
            const comment = `<!-- flightctl-build-status -->
            ## â³ Build in Progress...
            
            Building FlightCtl artifacts for this PR.
            
            ### ðŸ“‹ Build Info
            
            - **Image Tag:** \`${tag}\`
            - **Run ID:** \`${runId}\`
            - **Status:** ðŸ”„ Building...
            - **Build logs:** [View workflow run](${runUrl})
            
            ---
            This comment will be updated when the build completes.
            `;
            
            // Find existing comment from this workflow
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('flightctl-build-status')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
              console.log('Updated existing comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              console.log('Created new comment');
            }

  build-images:
    ## Todo freeze go version
    needs: [compute-tag]
    strategy:
      matrix:
        image: ['api', 'periodic', 'worker', 'cli-artifacts', 'alert-exporter', 'alertmanager-proxy', 'userinfo-proxy', 'db-setup', 'telemetry-gateway']
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Prepare version variables
        id: version-vars
        run: |
          set -euo pipefail
          SOURCE_GIT_TAG=$(git describe --tags --exclude latest 2>/dev/null || echo "v0.0.0-unknown")
          if [ ! -d ".git" ]; then
            SOURCE_GIT_TREE_STATE=clean
          elif git diff --quiet; then
            SOURCE_GIT_TREE_STATE=clean
          else
            SOURCE_GIT_TREE_STATE=dirty
          fi
          SOURCE_GIT_COMMIT=$(git rev-parse --short "HEAD^{commit}" 2>/dev/null || echo "unknown")

          {
            echo "git_tag=${SOURCE_GIT_TAG}"
            echo "git_tree_state=${SOURCE_GIT_TREE_STATE}"
            echo "git_commit=${SOURCE_GIT_COMMIT}"
          } >> "$GITHUB_OUTPUT"

      - name: Set up build output dir
        run: |
          mkdir -p digests

      - name: Build image
        id: build
        uses: redhat-actions/buildah-build@v2
        with:
          image: quay.io/flightctl/flightctl-${{ matrix.image }}
          tags: ${{ needs.compute-tag.outputs.tag }}
          labels: |
            org.flightctl.flightctl-${{ matrix.image }}.github.repository=${{ github.repository }}
            org.flightctl.flightctl-${{ matrix.image }}.github.actor=${{ github.actor }}
            org.flightctl.flightctl-${{ matrix.image }}.github.run_id=${{ github.run_id }}
            org.flightctl.flightctl-${{ matrix.image }}.github.sha=${{ github.sha }}
            org.flightctl.flightctl-${{ matrix.image }}.github.ref_name=${{ github.ref_name }}
            quay.expires-after=${{ inputs.expires_after }}
          build-args: |
            SOURCE_GIT_TAG=${{ steps.version-vars.outputs.git_tag }}
            SOURCE_GIT_TREE_STATE=${{ steps.version-vars.outputs.git_tree_state }}
            SOURCE_GIT_COMMIT=${{ steps.version-vars.outputs.git_commit }}
          extra-args: |
            --ulimit nofile=10000:10000
          containerfiles: Containerfile.${{ matrix.image }}
          context: .

      - name: Tag and save image archive
        id: save
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          IMAGE: ${{ steps.build.outputs.image }}      # e.g. quay.io/org/flightctl
          MATRIX_IMAGE: ${{ matrix.image }}            # e.g. api, worker
        run: |
          set -euo pipefail
          
          ARCHIVE_NAME="image-flightctl-${MATRIX_IMAGE}.tar"
          
          echo "Saving ${IMAGE}:${TAG} to ${ARCHIVE_NAME}"
          podman save -o "${ARCHIVE_NAME}" "${IMAGE}:${TAG}"
          
          mkdir -p digests
          
          DIGEST="$(podman inspect "${IMAGE}:${TAG}" --format '{{.Digest}}' || true)"
          DIGEST_FILE="digests/${MATRIX_IMAGE}.txt"
          printf "%s\n" "${DIGEST}" > "${DIGEST_FILE}"
          
          {
            echo "archive=${ARCHIVE_NAME}"
            echo "digest=${DIGEST}"
            echo "digest_file=${DIGEST_FILE}"
          } >> "$GITHUB_OUTPUT"

      - name: Upload image archive
        uses: actions/upload-artifact@v4
        with:
          name: image-flightctl-${{ matrix.image }}
          path: ${{ steps.save.outputs.archive }}
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

      - name: Upload digest artifact
        uses: actions/upload-artifact@v4
        with:
          name: digest-${{ matrix.image }}
          path: ${{ steps.save.outputs.digest_file }}
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

  bundle-images:
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-images]
    steps:
      - name: Download all image artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: image-*
          path: images
          merge-multiple: true

      - name: Load images and create bundle
        run: |
          set -euo pipefail
          TAG="${{ needs.compute-tag.outputs.tag }}"
          
          echo "Loading individual image archives..."
          for archive in images/*.tar; do
            [ -e "$archive" ] || continue
            echo "Loading $archive..."
            podman load -i "$archive"
          done
          
          echo "Getting list of loaded flightctl images with tag: $TAG"
          mapfile -t loaded_images < <(podman images --format "{{.Repository}}:{{.Tag}}" | grep "quay\.io/flightctl/flightctl-.*:${TAG}")
          
          echo "Creating bundle with ${#loaded_images[@]} images:"
          printf '  %s\n' "${loaded_images[@]}"
          
          podman save --format docker-archive -o flightctl-images-bundle.tar -m "${loaded_images[@]}"
          
          echo "Bundle created: $(ls -lh flightctl-images-bundle.tar)"

      - name: Upload images bundle
        uses: actions/upload-artifact@v4
        with:
          name: flightctl-images-bundle
          path: flightctl-images-bundle.tar
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

  service-images-manifest:
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-images]
    steps:
      - name: Download image digest artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: digest-*
          path: digests
          merge-multiple: true

      - name: Produce service images manifest
        run: |
          set -euo pipefail
          TAG='${{ needs.compute-tag.outputs.tag }}'
          ARTIFACT_BASE_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts"
          images=(
            flightctl-api
            flightctl-db-setup
            flightctl-worker
            flightctl-periodic
            flightctl-alert-exporter
            flightctl-alertmanager-proxy
            flightctl-cli-artifacts
            flightctl-userinfo-proxy
            flightctl-telemetry-gateway
          )
          printf '{"serviceImages":{' > service-images.json
          first=1
          for img in "${images[@]}"; do
            artifact_name="image-${img#flightctl-}"
            archive_name="${img}-${TAG}.tar"
            digest_file="digests/${img#flightctl-}.txt"
            if [ ! -f "$digest_file" ]; then
              echo "Missing digest file: $digest_file" >&2
              exit 1
            fi
            digest=$(cat "$digest_file")
            if [ $first -eq 0 ]; then printf ',' >> service-images.json; fi
            first=0
            printf '"%s":{"archiveName":"%s","artifactName":"%s","artifactUrl":"%s","digest":"%s"}' "$img" "$archive_name" "$artifact_name" "$ARTIFACT_BASE_URL" "$digest" >> service-images.json
          done
          printf '}}' >> service-images.json
          cat service-images.json

      - name: Upload service images manifest
        uses: actions/upload-artifact@v4
        with:
          name: service-images-manifest
          path: service-images.json
          compression-level: 0
          if-no-files-found: error
          retention-days: 1


  build-helm-charts:
    runs-on: ubuntu-24.04
    needs: [compute-tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Build helm charts
        id: build-charts
        run: |
          set -euo pipefail
          TAG="${{ needs.compute-tag.outputs.tag }}"
          helm dependency build ./deploy/helm/flightctl
          helm package ./deploy/helm/flightctl \
            --version "$TAG" \
            --app-version "$TAG"
          
          CHART_FILE="flightctl-${TAG}.tgz"
          DIGEST=$(sha256sum "$CHART_FILE" | awk '{print $1}')
          echo "sha256:${DIGEST}" > charts-digest.txt
          echo "chart_file=$CHART_FILE" >> "$GITHUB_OUTPUT"
          echo "digest=sha256:${DIGEST}" >> "$GITHUB_OUTPUT"

      - name: Upload helm chart artifact
        uses: actions/upload-artifact@v4
        with:
          name: helm-chart
          path: ${{ steps.build-charts.outputs.chart_file }}
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

      - name: Produce charts manifest
        run: |
          set -euo pipefail
          name="flightctl"
          version="${{ needs.compute-tag.outputs.tag }}"
          artifact_url="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts"
          digest="${{ steps.build-charts.outputs.digest }}"
          chart_file="${{ steps.build-charts.outputs.chart_file }}"
          jq -n \
            --arg n "$name" \
            --arg v "$version" \
            --arg u "$artifact_url" \
            --arg d "$digest" \
            --arg f "$chart_file" \
            '{charts:{($n):{version:$v,artifactUrl:$u,digest:$d,chartFile:$f}}}' > charts.json
          cat charts.json

      - name: Upload charts manifest
        uses: actions/upload-artifact@v4
        with:
          name: charts-manifest
          path: charts.json
          compression-level: 0
          if-no-files-found: error
          retention-days: 1




  build-rpms:
    runs-on: ubuntu-24.04
    needs: [compute-tag]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Build RPMs
        run: make rpm

      - name: Upload RPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpms-${{ github.sha }}
          path: bin/rpm/*.rpm
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

      - name: Produce rpms manifest
        run: |
          set -euo pipefail
          out='{"rpms":{"packages":['
          first=1
          for f in bin/rpm/*.rpm; do
            [ -e "$f" ] || continue
            bn=$(basename "$f")
            if [[ "$bn" =~ ^(.+)-([0-9][^-]*)-([^.]*)\.([^.]+)\.rpm$ ]]; then
              name="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"
              release="${BASH_REMATCH[3]}"
              arch="${BASH_REMATCH[4]}"
            else
              # Fallback: best-effort parse
              name="${bn%%-*}"
              rest="${bn#*-}"
              version="${rest%%-*}"
              rest2="${rest#*-}"
              release="${rest2%%.*}"
              arch="${bn##*.}"
              arch="${arch%.rpm}"
            fi
            url="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}#artifacts"
            pkg=$(jq -cn --arg n "$name" --arg v "$version" --arg r "$release" --arg a "$arch" --arg u "$url" '{name:$n,version:$v,release:$r,architecture:$a,url:$u}')
            if [ $first -eq 0 ]; then out+="","$pkg"; else out+="$pkg"; fi
            first=0
          done
          out+=']} }'
          printf '%s' "$out" > rpms.json
          cat rpms.json

      - name: Upload rpms manifest
        uses: actions/upload-artifact@v4
        with:
          name: rpms-manifest
          path: rpms.json
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

  build-agent-images:
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-rpms]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Prepare version variables
        id: version-vars
        run: |
          set -euo pipefail
          SOURCE_GIT_TAG=$(git describe --tags --exclude latest 2>/dev/null || echo "v0.0.0-unknown")
          if [ ! -d ".git" ]; then
            SOURCE_GIT_TREE_STATE=clean
          elif git diff --quiet; then
            SOURCE_GIT_TREE_STATE=clean
          else
            SOURCE_GIT_TREE_STATE=dirty
          fi
          SOURCE_GIT_COMMIT=$(git rev-parse --short "HEAD^{commit}" 2>/dev/null || echo "unknown")

          {
            echo "git_tag=${SOURCE_GIT_TAG}"
            echo "git_tree_state=${SOURCE_GIT_TREE_STATE}"
            echo "git_commit=${SOURCE_GIT_COMMIT}"
          } >> "$GITHUB_OUTPUT"

      - name: Restore APT cache
        id: cache-apt-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            /var/cache/apt
            /var/lib/apt
          key: ${{ runner.os }}-apt-e2e-${{ hashFiles('.github/actions/setup-dependencies/action.yaml') }}
          restore-keys: |
            ${{ runner.os }}-apt-e2e-

      - name: Set permissions for APT after restore
        run: sudo mkdir -p /var/cache/apt /var/lib/apt && sudo chown -R root:root /var/cache/apt /var/lib/apt

      - name: Restore Go modules cache
        id: cache-go-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Restore DNF cache
        id: cache-dnf-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            /var/cache/dnf
            /var/lib/dnf
          key: ${{ runner.os }}-dnf-e2e
          restore-keys: |
            ${{ runner.os }}-dnf-

      - name: Set permissions for DNF after restore
        run: sudo mkdir -p /var/cache/dnf /var/lib/dnf && sudo chown -R root:root /var/cache/dnf /var/lib/dnf

      - name: Restore bootc-image-builder cache
        id: cache-bootc-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            bin/dnf-cache
            bin/osbuild-cache
          key: ${{ runner.os }}-bootc-cache-e2e-${{ hashFiles('test/scripts/agent-images/Containerfile-e2e-base.local') }}
          restore-keys: |
            ${{ runner.os }}-bootc-cache-e2e-
      - name: Download RPM artifacts
        uses: actions/download-artifact@v4
        with:
          name: rpms-${{ github.sha }}
          path: rpms

      - name: Build agent container images
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
          SOURCE_GIT_TAG: ${{ steps.version-vars.outputs.git_tag }}
          SOURCE_GIT_TREE_STATE: ${{ steps.version-vars.outputs.git_tree_state }}
          SOURCE_GIT_COMMIT: ${{ steps.version-vars.outputs.git_commit }}
        run: |
          set -euo pipefail
          
          export IMAGE_REPO="quay.io/flightctl/flightctl-device"
          export BUILD_QCOW2=false
          export PARALLEL_JOBS=4
          
          ./test/scripts/agent-images-v2/build_agent_images.sh

      - name: Save agent images to bundle
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
        run: |
          set -euo pipefail
          
          IMAGE_REPO="quay.io/flightctl/flightctl-device"
          
          echo "Creating bundle of agent images..."
          mapfile -t images < <(podman images --format "{{.Repository}}:{{.Tag}}" | grep "${IMAGE_REPO}:.*-${TAG}")
          
          echo "Found ${#images[@]} agent images:"
          printf '  %s\n' "${images[@]}"
          
          podman save --format docker-archive -o agent-images-bundle.tar -m "${images[@]}"
          
          echo "Bundle created: $(ls -lh agent-images-bundle.tar)"

      - name: Upload agent images bundle
        uses: actions/upload-artifact@v4
        with:
          name: agent-images-bundle
          path: agent-images-bundle.tar
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

  build-agent-qcow2:
    runs-on: ubuntu-24.04
    needs: [compute-tag, build-agent-images]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Download agent images bundle
        uses: actions/download-artifact@v4
        with:
          name: agent-images-bundle

      - name: Load agent images
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
        run: |
          set -euo pipefail
          
          echo "Loading agent images bundle..."
          podman load -i agent-images-bundle.tar
          
          echo "Loaded images:"
          podman images | grep flightctl-device

      - name: Build qcow2 image
        env:
          TAG: ${{ needs.compute-tag.outputs.tag }}
        run: |
          set -euo pipefail
          
          IMAGE_REPO="quay.io/flightctl/flightctl-device"
          BASE_IMAGE="${IMAGE_REPO}:base-${TAG}"
          
          echo "Building qcow2 image from ${BASE_IMAGE}..."
          
          mkdir -p output
          mkdir -p dnf-cache
          mkdir -p osbuild-cache
          
          sudo podman run --rm \
                          -it \
                          --privileged \
                          --pull=newer \
                          --security-opt label=type:unconfined_t \
                          -v "$(pwd)"/output:/output \
                          -v "$(pwd)"/dnf-cache:/var/cache/dnf:Z \
                          -v "$(pwd)"/osbuild-cache:/var/cache/osbuild:Z \
                          -v /var/lib/containers/storage:/var/lib/containers/storage \
                          quay.io/centos-bootc/bootc-image-builder:latest \
                          build \
                          --type qcow2 \
                          "${BASE_IMAGE}"
          
          sudo chown -R "${USER}:$(id -gn ${USER})" output
          
          echo "qcow2 image created: $(ls -lh output/qcow2/disk.qcow2)"

      - name: Upload qcow2 image
        uses: actions/upload-artifact@v4
        with:
          name: agent-qcow2-image
          path: output/qcow2/disk.qcow2
          compression-level: 1
          if-no-files-found: error
          retention-days: 1

  build-flightctl-cli:
    name: Build Flightctl CLI Binaries
    needs: [compute-tag]
    strategy:
      matrix:
        tag: [ "linux-amd64", "linux-arm64", "darwin-amd64", "darwin-arm64", "windows-amd64", "windows-arm64" ]
        include:
          # Linux builds
          - tag: linux-amd64
            arch: amd64
            os: linux
            zip: .tar.gz
            ext: ""
          - tag: linux-arm64
            arch: arm64
            os: linux
            zip: .tar.gz
            ext: ""
          # macOS builds
          - tag: darwin-amd64
            arch: amd64
            os: darwin
            zip: .zip
            ext: ""
          - tag: darwin-arm64
            arch: arm64
            os: darwin
            zip: .zip
            ext: ""
          # Windows builds
          - tag: windows-amd64
            arch: amd64
            os: windows
            zip: .zip
            ext: .exe
          - tag: windows-arm64
            arch: arm64
            os: windows
            zip: .zip
            ext: .exe

    runs-on: ubuntu-24.04
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      # Install dependencies
      - name: Install Dependencies
        run: go mod tidy

      - name: Build
        run: |
          DISABLE_FIPS="true" GOOS="${{ matrix.os }}" GOARCH="${{ matrix.arch }}" make build-cli
          mv "bin/flightctl${{ matrix.ext }}" "flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}"
          SHA=$(shasum -a 256 flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }} | cut -d' ' -f1)
          echo ${SHA} > flightctl-${{ matrix.os }}-${{ matrix.arch}}-sha256.txt
          if [ "${{ matrix.zip }}" = ".zip" ]; then
            zip flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.zip }} flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}
          else
            tar cvf flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.zip }} flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}
          fi

      - name: Save zip
        uses: actions/upload-artifact@v4
        with:
          name: flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.zip }}
          path: flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.zip }}

      - name: Save binary
        uses: actions/upload-artifact@v4
        with:
          name: flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}
          path: flightctl-${{ matrix.os }}-${{ matrix.arch}}${{ matrix.ext }}

      - name: Save checksum
        uses: actions/upload-artifact@v4
        with:
          path: flightctl-${{ matrix.os }}-${{ matrix.arch}}-sha256.txt
          name: flightctl-${{ matrix.os }}-${{ matrix.arch}}-sha256.txt

  artifacts-ready:
    runs-on: ubuntu-24.04
    needs: [compute-tag, service-images-manifest, build-rpms, build-helm-charts, build-flightctl-cli, bundle-images, build-agent-images, build-agent-qcow2]
    if: always()
    steps:
      - name: Download service images manifest
        uses: actions/download-artifact@v4
        with:
          name: service-images-manifest
          path: manifests

      - name: Download charts manifest
        uses: actions/download-artifact@v4
        with:
          name: charts-manifest
          path: manifests

      - name: Download rpms manifest
        uses: actions/download-artifact@v4
        with:
          name: rpms-manifest
          path: manifests

      - name: Assemble final build manifest
        run: |
          set -euo pipefail
          ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          meta=$(jq -n --arg bid "github-run-${GITHUB_RUN_ID}" --arg sha "${GITHUB_SHA}" --arg ts "$ts" '{buildId:$bid,commitSha:$sha,timestamp:$ts}')
          parts="{}"
          for f in manifests/*.json; do
            [ -e "$f" ] || continue
            parts=$(jq -s 'reduce .[] as $i ({}; . * $i)' <(echo "$parts") "$f")
          done
          jq -s '.[0] * .[1]' <(echo "$meta") <(echo "$parts") > build-manifest.json
          cat build-manifest.json

      - name: Upload build manifest
        uses: actions/upload-artifact@v4
        with:
          name: build-manifest
          path: build-manifest.json
          compression-level: 0
          if-no-files-found: error
          retention-days: 1

      - name: Update PR comment with artifact info
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const tag = '${{ needs.compute-tag.outputs.tag }}';
            const runId = '${{ github.run_id }}';
            const chartFile = `flightctl-${tag}.tgz`;
            const artifactsUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}#artifacts`;
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;
            
            const comment = `<!-- flightctl-build-status -->
            ## ðŸŽ‰ Build Artifacts Ready!
            
            Your PR build has completed successfully. The artifacts are ready to download and test.
            
            ### ðŸ“¦ Artifacts
            
            - **Image Tag:** \`${tag}\`
            - **Helm Chart:** \`${chartFile}\`
            - **Run ID:** \`${runId}\`
            - **Status:** âœ… Complete
            - **Build logs:** [View workflow run](${runUrl})
            - **All artifacts:** [GitHub Actions Artifacts](${artifactsUrl})
            
            ### ðŸš€ Quick Start Commands
            
            #### 1ï¸âƒ£ Download artifacts:
            \`\`\`bash
            gh run download ${runId} -n "helm-chart" -n "flightctl-images-bundle"
            \`\`\`
            
            #### 2ï¸âƒ£ Load images into kind cluster:
            \`\`\`bash
            kind load image-archive flightctl-images-bundle/flightctl-images-bundle.tar
            \`\`\`
            
            #### 3ï¸âƒ£ Install/upgrade with Helm:
            \`\`\`bash
            helm upgrade --install flightctl helm-chart/${chartFile}
            \`\`\`
            
            ### ðŸ§ª E2E Testing Artifacts
            
            Agent images for e2e testing are also available:
            
            - **Agent Images Bundle:** \`agent-images-bundle.tar\`
            - **Agent QCOW2 Image:** \`agent-qcow2-image/disk.qcow2\`
            
            Download agent images:
            \`\`\`bash
            gh run download ${runId} -n "agent-images-bundle" -n "agent-qcow2-image"
            \`\`\`
            
            ---
            ðŸ’¡ **Tip:** Make sure you have \`gh\` CLI installed and authenticated to download artifacts.
            `;
            
            // Find existing comment from this workflow
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('flightctl-build-status')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
              console.log('Updated existing comment');
            } else {
              // Create new comment (fallback in case initial comment failed)
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              console.log('Created new comment');
            }

##################
### SMOKE TEST ###
##################
  smoke:
    runs-on: ubuntu-24.04
    needs: [artifacts-ready]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
     
      - name: Download backend images
        uses: actions/download-artifact@v4
        with:
          name: flightctl-images-bundle
      
      - name: Download Helm pkg
        uses: actions/download-artifact@v4
        with:
          name: helm-chart

      - name: List files
        run: ls -la

      - name: Create cluster
        run: make cluster
 



































