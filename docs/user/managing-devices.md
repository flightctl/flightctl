# Managing Devices

## Enrolling Devices

The first time the Flight Control Agent runs, it generates a cryptographic key pair that serves as the device's unique cryptographic identity. The pair's private key never leaves the device, so that the device cannot be duplicated or impersonated. The cryptographic identity is registered with the Flight Control Service during enrollment and gets wiped during device decommissioning.

When the device is not yet enrolled, the agent performs service discovery to find its Flight Control Service instance. It then establishes a secure, mTLS-protected network connection to the Service using the X.509 enrollment certificate it has been provided with during image building or device provisioning. Next, it submits an Enrollment Request to the service that includes a description of the device's hardware and operating system as well as an X.509 Certificate Signing Request (CSR) including its cryptographic identity to obtain its initial management certificate. At this point, the device is not yet considered trusted and therefore remains quarantined in a "device lobby" until its Enrollment Request has been approved or denied by an authorized user (e.g. a administrator, an installer persona, or an auto-approver process).

### Enrolling using the Web UI

### Enrolling using the CLI

You can list all devices currently waiting to be approved by running the following command:

```console
flightctl get enrollmentrequests
```

The output should look similar to this:

```console
NAME                                                  APPROVAL  APPROVER  APPROVED LABELS
54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg  Pending   <none>    <none>    
```

The unique device name is generated by the agent and cannot be changed. By default, the agent chooses the "device fingerprint", a base32-encoded hash of the agent's public key, as device name.

You can approve an Enrollment Request using the `flightctl approve` command and the name of the Enrollment Request to be approved. You can optionally also add labels to the device (see [Organizing Devices](managing-devices.yaml#organizing-devices)) using the `--label` or `-l` flag. For example:

```console
flightctl approve -l region=eu-west-1 -l site=factory-berlin enrollmentrequest/54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg
```

When listing devices waiting to be approved once more using the `flightctl get enrollmentrequests` command, the output should look similar to this:

```console
NAME                                                  APPROVAL  APPROVER  APPROVED LABELS
54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg  Approved  demouser  region=eu-west-1,site=factory-berlin
```

Once approved, the device will get issued its initial management certificate and get registered to the device inventory and is now ready to be managed.

## Viewing the Device Inventory and Device Details

### Viewing using the Web UI

### Viewing using the CLI

You can see the devices in the device inventory by running the following command:

```console
flightctl get devices
```

The output will be a table similar to this:

```console
NAME                                                  ALIAS    OWNER   SYSTEM  UPDATED     APPLICATIONS  LAST SEEN
54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg  <none>   <none>  Online  Up-to-date  <none>        3 seconds ago
```

You can see the details of this device in YAML format by running the following command:

```console
flightctl get device/54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg -o yaml
```

The output will look similar to this:

```yaml
apiVersion: v1alpha1
kind: Device
metadata:
  name: 54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg
  labels:                                    # <-- user-defined labels assigned to this device
    region: eu-west-1
    site: factory-berlin
spec:
  os:
    image: quay.io/flightctl/rhel:9.5        # <-- the device's target OS image version
  config:
  - name: my-os-configuration                # <-- the device's target OS configuration (here: read from a git repo)
    configType: GitConfigProviderSpec
    gitRef:
      path: /configuration
      repository: my-configuration-repo
      targetRevision: production
status:
  os:
    image: quay.io/flightctl/rhel:9.5        # <-- the device's current OS image version
  config:
    renderedVersion: "1"                     # <-- the device's current OS configuration version
  applications:
    data: {}                                 # <-- the device's current list of deployed applications
    summary:
      status: Unknown                        # <-- health status of applications on the device
  resources:                                 # <-- whether sufficient CPU/disk/memory resources are available
    cpu: Healthy
    disk: Healthy
    memory: Healthy
  systemInfo:                                # <-- basic information about the system
    architecture: amd64
    bootID: 037750f7-f293-4c5b-b06e-481eef4e883f
    operatingSystem: linux
  summary:
    info: ""
    status: Online                           # <-- online status of the device
  updated:
    status: UpToDate                         # <-- update status of the device
  lastSeen: "2024-08-28T11:45:34.812851905Z" # <-- when the device last checked-in
[...]
```

## Organizing Devices

You can organize your devices by assigning them labels, for example to record their location ( ("region=emea", "site=factory-berlin"), hardware type ("hw-model=jetson", "hw-generation=orin"), or purpose ("device-type=autonomous-forklift"). This then allows you select devices by these labels when viewing the device inventory or applying operations to them.

As good practice, labels should take the form of `key=value` pairs, whereby the key is the criterion you want to group by. However, labels that only consist of keys are also allowed.

Labels must follow certain rules to be valid (in fact, these are the same as for [Kubernetes](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/)):

* Keys and value must each be 63 characters or less. Value may be omitted.
* Keys and values may consist of alphanumeric characters (`a-z`, `A-Z`, `0-9`). They may also contain dashes (`-`), underscores (`_`), dots (`.`), but not as the first or last character.

Once devices are labeled, you can select a subset of devices by writing a "label selector", which is a comma-separated list of labels devices must have to be selected, for example `site=factory-berlin,device-type=autonomous-forklift`).

There are multiple ways when and how to apply labels to devices:

* You can define a set of default labels during image building that get automatically applied to all devices deploying that image.
* You can assign initial labels during enrollment (see [Enrolling Devices](managing-devices.md#enrolling-devices)).
* You can edit labels post-enrollment, which is described in the following sections.

### Using Labels on the Web UI

### Using Labels on the CLI

You can view devices in your inventory including their labels by using the `-o wide` option:

```console
flightctl get devices -o wide
```

```console
NAME                                                  ALIAS    OWNER   SYSTEM  UPDATED     APPLICATIONS  LAST SEEN      LABELS
54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg  <none>   <none>  Online  Up-to-date  <none>        3 seconds ago  region=eu-west-1,site=factory-berlin
hnsu33339f8m5pjqrbh5ak704jjp92r95a83sd5ja8cjnsl7qnrg  <none>   <none>  Online  Up-to-date  <none>        1 minute ago   region=eu-west-1,site=factory-madrid
```

You can view devices in your inventory with a specific label or set of labels by using the `-l key=value` option one or more times:

```console
flightctl get devices -l site=factory-berlin -o wide
```

```console
NAME                                                  ALIAS    OWNER   SYSTEM  UPDATED     APPLICATIONS  LAST SEEN      LABELS
54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg  <none>   <none>  Online  Up-to-date  <none>        3 seconds ago  region=eu-west-1,site=factory-berlin
```

You can update the labels of a given device by exporting the device's current definition into a file, editing the specification to update the labels, and then applying the updated definition. To export the device's current definition into a file called `my_device.yaml`, run the `flightctl get device` command with the device's name and the `-o yaml` output flag:

```console
flightctl get device/54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg -o yaml > my_device.yaml
```

Next, use your preferred editor to edit `my_device.yaml`, for example:

```yaml
apiVersion: v1alpha1
kind: Device
metadata:
  labels:
    some_key: some_value
    some_other_key: some_other_value
  name: 54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg
spec:
[...]
```

Save the edit, then apply the updated device definition using:

```console
flightctl apply -f my_device.yaml
```

When you now view the device's labels using `flightctl get devices -o wide` once more, you should see your changes applied:

```console
NAME                                                  ALIAS    OWNER   SYSTEM  UPDATED     APPLICATIONS  LAST SEEN      LABELS
54shovu028bvj6stkovjcvovjgo0r48618khdd5huhdjfn6raskg  <none>   <none>  Online  Up-to-date  <none>        3 minutes ago  some_key=some_value,some_other_key=some_other_value
hnsu33339f8m5pjqrbh5ak704jjp92r95a83sd5ja8cjnsl7qnrg  <none>   <none>  Online  Up-to-date  <none>        4 minutes ago  region=eu-west-1,site=factory-madrid
```

## Updating the OS

You can update a device's OS by updating the target OS image name or version in the device's specification. The next time the agent checks in, it learns of the requested update and automatically starts downloading and verifying the new OS version in the background. It then schedules the actual system update to be performed according to the update policy. When the time has come to update, it installs the new version in parallel and performs a reboot into the new version.

Flight Control currently supports the following image types and image references formats:

| Image Type | Image Reference |
| ---------- | --------------- |
| [bootc](https://github.com/containers/bootc) | An OCI image reference to a container registry. Example: `quay.io/flightctl-demos/rhel:9.5` |

During the process, the agent sends status updates to the service. You can monitor the update progress by viewing the device status.

### Updating the OS on the Web UI

### Updating the OS on the CLI

To update a device using the CLI, get the device's current resource manifest, edit it to specify the new OS name and version target, then apply the updated resource.

```yaml
apiVersion: v1alpha1
kind: Device
metadata:
  name: some_device_name
spec:
[...]
  os:
    image: quay.io/flightctl/rhel:9.5
[...]
```

## Managing OS Configuration

With image-based Linux OSes, it is best practice to include OS-level / host configuration into the OS image for maximum consistency and repeatability. To update configuration, a new OS image should be created and devices updated to the new image.

However, there are scenarios where this is impractical, for example, when configuration is missing in the image, needs to be specific to a device, or needs to be update-able at runtime without updating the OS image and rebooting. For these cases, Flight Control allows users to declare a set of configuration files that shall be present on the device's file system.

Conceptually, this set of configuration files can be thought of as an additional, dynamic layer on top of the OS image's layers. The Flight Control Agent applies updates to this layer transactionally, ensuring that either all files have been successfully updated in the file system or have been returned to their pre-update state. Further, if the user updates both a devices OS and configuration set at the same time, the Flight Control Agent will first update the OS, then apply the specified configuration set on top.

> [!Important] After the Flight Control Agent has updated the configuration on disk, this configuration still needs to be *activated*. That means, running services need to reload the new configuration into memory for it to become effective. If the update involves a reboot, services will be restarted by systemd in the right order with the new configuration automatically. If the update does not involve a reboot, many services can detect changes to their configuration files and automatically reload them. When a service does not support this, you [use Device Lifecycle Hooks](managing-devices.md#using-device-lifecycle-hooks) to specify rules like "if configuration file X has changed, run command Y". Also refer to this section for the set of default rules that the Flight Control Agent applies.

Users can specify a list of configurations sets, in which case the Flight Control Agent applies the sets in sequence and on top of each other, such that in case of conflict the "last one wins".

Configuration can come from multiple sources, called "configuration providers" in Flight Control. Flight Control currently supports the following configuration providers:

* **Git Config Provider:** Fetches device configuration files from a Git repository.
* **Kubernetes Secret Provider:** Fetches a Secret from a Kubernetes cluster and writes its content to the device's file system.
* **HTTP Config Provider:** Fetches device configuration files from an HTTP(S) endpoint.
* **Inline Config Provider:** Allows specifying device configuration files inline in the device manifest without querying external systems.

These providers are described in the following.

### Getting Configuration from a Git Repository

You can store device configuration in a Git repository such as GitHub or GitLab and let Flight Control synchronize it to the device's file system by adding a Git Config Provider.

The Git Config Provider takes the following parameters:

| Parameter | Description |
| --------- | ----------- |
| Repository | The name of a Repository resource defined in Flight Control. |
| TargetRevision | The branch, tag, or commit of the repository to checkout. |
| Path | The subdirectory of the repository that contains the configuration. |
| MountPath | (Optional) The directory in the device's file system to write the configuration to. Defaults to the file system root `/`. |

The Repository resource definition tells Flight Control the Git repository to connect to and which protocol and access credentials to use. It needs to be set up once (see Setting Up Repositories) and can then be used to configure multiple devices or fleets.

#### Example

A assume a Git repository `github.com/flightctl/flightctl-demos` that in its branch `production` stores device network and time server configuration organized by deployment site as follows:

```console
.
├── factory-a
│   └── etc
│       ├── chrony.conf
│       └── NetworkManager
│           └── system-connections
│               └── wifi-access.nmconnection
└── factory-b
    └── etc
        ├── chrony.conf
        └── NetworkManager
            └── system-connections
                └── wifi-access.nmconnection
```

First, create a new Repository resource. Give it a name that you can later reference in your configurations, for example "site-settings", and select the Repository type "git". Next, enter the URL of your git repository, in this case `https://github.com/flightctl/flightctl-demos.git`.

You can now reference this Repository when you configure devices. For example, to apply the configuration files under `/factory-a` to a device, add a Git Config Provider to the device's specification using the following parameters:

| Parameter | Value |
| --------- | ----- |
| Repository | site-settings |
| TargetRevision | production |
| Path | /factory-a |
| MountPath | (leave empty to use the default `/` root directory) |

### Getting Secrets from a Kubernetes Cluster

You can let Flight Control query the Kubernetes cluster it is running on for a Kubernetes Secret. The content of that Secret can then be written to a path on the device file system.

The Kubernetes Secret Provider takes the following parameters:

| Parameter | Description |
| --------- | ----------- |
| Name | The name of the Secret. |
| NameSpace | The namespace of the Secret. |
| MountPath | The directory in the device's file system to write the secret's content to. |

Note that Flight Control needs to have the permissions access Secrets in that namespace, for example by creating a ClusterRole and ClusterRoleBinding allowing the `flightctl-worker` service account "get" and "list" Secrets in that namespace.

### Getting Configuration from an HTTP Server

You can let Flight Control query an HTTP server for configuration. This HTTP server can then serve static or dynamically generated configuration for a device.

The HTTP Config Provider takes the following parameters:

| Parameter | Description |
| --------- | ----------- |
| Repository | The name of a Repository resource defined in Flight Control. |
| Suffix | The suffix to append to the base URL defined in the Repository resource. It can include path and query parameters such as `/path/to/endpoint?query=param` |
| FilePath | The path to the file on the device's file system in which to store the returned value of the HTTP Server. |

The Repository resource definition tells Flight Control the HTTP server to connect to and which protocol and access credentials to use. It needs to be set up once (see Setting Up Repositories) and can then be used to configure multiple devices or fleets.

### Specifying Configuration Inline in the Device Spec

You specify configuration inline in a device's specification, so Flight Control does not need to connect to external systems to fetch configuration.

The Inline Config Provider takes a list of file specifications, whereby each file specification takes the following parameters:

| Parameter | Description |
| --------- | ----------- |
| Path | The absolute path to the file on the device. Note that any existing file will be overwritten. |
| Content | The plain text (UTF-8) or base64-encoded content of the file. |
| ContentEncoding | How the contents are encoded. Must be either "plain" or "base64". Defaults to "plain". |
| Mode | (Optional) The file’s permission mode. You may specify the more familiar octal with a leading zero (e.g., 0644) or as a decimal without a leading zero (e.g., 420). Setuid/setgid/sticky bits are supported. If not specified the permission mode for files defaults to 0644.|
| User | (Optional) The file's owner, specified either as a name or numeric ID. Defaults to "root". |
| Group | (Optional) The file's group, specified either as a name or numeric ID. |

### Managing Configuration on the Web UI

### Managing Configuration on the CLI

To implement the example from [Getting Configuration from a Git Repository](managing-devices.md#getting-configuration-from-a-git-repository), first, create a file `site-settings-repo.yaml` that contains the following definition for a Repository resource named `site-settings`:

```yaml
apiVersion: v1alpha1
kind: Repository
metadata:
  name: site-settings
spec:
  type: git
  url: https://github.com/flightctl/flightctl-demos.git
```

Create the Repository resource by applying the file:

```console
flightctl apply -f site-settings-repo.yaml`
```

Verify the resource has been correctly created and is accessible by Fight Control by running:

```console
flightctl get repository/site-settings
```

The output should look like this:

```console
NAME           TYPE  REPOSITORY URL                                ACCESSIBLE
site-settings  git   https://github.com/flightctl/flightctl-demos  True
```

To apply the configuration for `factory-a` to a device, you would update the device's specification as follows:

```yaml
apiVersion: v1alpha1
kind: Device
metadata:
  name: some_device_name
spec:
[...]
  config:
  - name: factory-a-settings
    configType: GitConfigProviderSpec
    gitRef:
      repository: site-settings
      targetRevision: production
      path: /factory-a
[...]
```

## Managing Applications

You can deploy, update, or undeploy applications on a device by updating the list of applications in the device's specification. The next time the agent checks in, it learns of the change in the specification, downloads any new or updated application packages and images from an OCI-compatible registry, and deploys them to the appropriate application runtime or removes them from that runtime.

The following table shows the application runtimes and formats supported by Flight Control:

| Runtime | Descriptor Format | Package Format | Package Repository | Note |
| ------- | ----------------- | -------------- | ------------------ | ---- |
| Podman | [podman-compose](https://github.com/containers/podman-compose) | (name TBD) | OCI registry | requires `podman-compose` installed on device |
| Podman | [podman-compose](https://github.com/containers/podman-compose) | (unpackaged) | git or inline | requires `podman-compose` installed on device |
| Podman | [Quadlet](https://docs.podman.io/en/stable/markdown/podman-systemd.unit.5.html) | (name TBD) | OCI registry | |
| Podman | [Quadlet](https://docs.podman.io/en/stable/markdown/podman-systemd.unit.5.html) | (unpackaged) | git or inline | |
| MicroShift | Kubernetes manifests from [Helm templates](https://helm.sh/docs/helm/helm_template/) | Helm Chart | OCI registry | requires `helm` installed on device |
| MicroShift | Kubernetes manifests from [kustomize](https://kustomize.io/) | (unpackaged) | git or inline | |

To deploy an application to a device, create a new entry in the "applications" section of the device's specification, specifying the following parameters:

| Parameter | Description |
| --------- | ----------- |
| Name | A user-defined name for the application. This will be used when the web UI and CLI list applications. |
| Image | A reference to an application package in an OCI registry. |
| EnvVars | (Optional) A list of key/value-pairs that will be passed to the deployment tool as environment variables or command line flags. |

For each application in the "applications" section of the device's specification, there exist a corresponding device status information that contains the following information:

| Status Field | Description |
| ------------ |-------------|
| Preparing   | Application deployed; containers initialized but not yet running. |
| Starting    | Application started; at least one container running, awaiting results. |
| Running     | All containers are running. |
| Error       | All containers failed. |
| Unknown     | Application started, no containers observed. |
| Completed   | All containers have completed successfully. |

### Managing Applications on the Web UI

### Managing Applications on the CLI

To deploy an application package from an OCI registry, specify it in the device's `spec.applications[]` as follows:

```yaml
apiVersion: v1alpha1
kind: Device
metadata:
  name: some_device_name
spec:
[...]
  applications:
  - name: wordpress
    image: quay.io/flightctl-demos/wordpress-app:latest
    envVars:
      WORDPRESS_DB_HOST: "mysql"
      WORDPRESS_DB_USER: "user"
      WORDPRESS_DB_PASSWORD: "password"
[...]
```

To deploy an unpackaged application from a Git repository, specify it in the device's `spec.applications[]` as follows:

```yaml
apiVersion: v1alpha1
kind: Device
metadata:
  name: some_device_name
spec:
[...]
  applications:
  - name: wordpress
    git:
      url: https://github.com/flightctl/flightctl-demos.git
      revision: v1.0
      path: /wordpress
    envVars:
      WORDPRESS_DB_HOST: "mysql"
      WORDPRESS_DB_USER: "user"
      WORDPRESS_DB_PASSWORD: "password"
[...]
```

To deploy an unpackaged application inline with the device specification, specify it in the device's `spec.applications[]` as follows:

```yaml
apiVersion: v1alpha1
kind: Device
metadata:
  name: some_device_name
spec:
[...]
  applications:
  - name: wordpress
    inline:
      podman-compose.yaml: |
        version: “3.7"
        services:
          wordpress:
            image: “wordpress:latest”
        [...]
    envVars:
      WORDPRESS_DB_HOST: "mysql"
      WORDPRESS_DB_USER: "user"
      WORDPRESS_DB_PASSWORD: "password"
[...]
```

## Creating Applications

### Creating OCI Registry Application Package

Define the application's functionality with the [Compose specification](https://github.com/compose-spec/compose-spec/blob/main/spec.md) and embed the compose file in a scratch container. Add the `appType=compose` label, then build and push the container to your OCI registry. Finally, reference the image in `spec.applications[]`.

```yaml
FROM scratch

COPY podman-compose.yaml /podman-compose.yaml

# required
LABEL appType="compose"

```

## Using Device Lifecycle Hooks

You can use device lifecycle hooks to make the agent run user-defined commands at specific points in the device's lifecycle. For example, you can add a shell script to your OS images that backs up your application data and then specify that this script shall be run and complete successfully before the agent can start updating the system.

The following device lifecycle hooks are supported:

| Lifecycle Hook | Description |
| -------------- | ----------- |
| `beforeUpdating` | This hook is called after the agent completed preparing for the update and before actually making changes to the system. If an action in this hook returns with failure, the agent aborts the update. |
| `afterUpdating` | This hook is called after the agent has written the update to disk. If an action in this hook returns with failure,the agent will abort and roll back the update. |
| `beforeRebooting` | This hook is called before the system reboots. The agent will block the reboot until running the action has completed or timed out. If any action in this hook returns with failure, the agent will abort and roll back the update. |
| `afterRebooting` | This hook is called when the agent first starts after a reboot. If any action in this hook returns with failure, the agent will report this but continue starting up. |

Refer to the [Device API status reference](device-api-statuses.md) a state diagram defining when each device lifecycle hook is called by the agent.

Device lifecycle hooks can be defined by adding rule files to one of two locations in the device's filesystem, whereby `${lifecyclehook}` is the all-lower-case name of the hook to be defined:

* Rules in the `/usr/lib/flightctl/hooks.d/${lifecyclehook}/` drop-in directory are read-only and thus have to be added to the OS image during [image building](building-images.md).
* Rules in the `/etc/flightctl/hooks.d/${lifecyclehook}/` drop-in directory are read-writable and can thus be updated at runtime using the methods described in [Managing OS Configuration](#managing-os-configuration).

If rules are defined in both locations they will be merged, whereby files under `/etc` take precedence over files of the same name under `/usr`. If multiple rule files are added to a hook's directory, they are processed in lexical order of their file names.

A rule file is written in YAML format and contains a list of one or more actions. An action can be to run an external command ("run action"). When multiple actions are specified for a hook, these actions are performed in sequence, finishing one action before starting the next. If an action returns with failure, later actions will not be executed.

A run action takes the following parameters:

| Parameter | Description |
| --------- | ----------- |
| Run | The absolute path to the command to run, followed by any flags or arguments.<br/><br/>Example: `/usr/bin/nmcli connection reload`.<br/><br/>Note that the command is not executed in a shell, so you cannot use shell variables like `$PATH` or `$HOME` or chain commands (`\|` or `;`). However, it is possible to start a shell yourself if necessary by specifying the shell as command to run.<br/><br/>Example: `/usr/bin/bash -c 'echo $SHELL $HOME $USER'` |
| EnvVars | (Optional) A list of key/value-pairs to set as environment variables for the command. |
| WorkDir | (Optional) The directory the command will be run from. |
| Timeout | (Optional) The maximum duration allowed for the action to complete. The duration must be be specified as a single positive integer followed by a time unit. Supported time units are `s` for seconds, `m` for minutes, and `h` for hours. |
| If | (Optional) A list of conditions that must be true for the action to be run (see below). If not provided, actions will run unconditionally. |

By default, actions are performed every time the hook is triggered. However, for the `afterUpdating` hook you can use the `If` parameter to add conditions that must be true for an action to be performed, otherwise the action will be skipped.

In particular, to only run an action if a given file or directory has changed during the update, you can define a "path condition" that takes the following parameters:

| Parameter | Description |
| --------- | ----------- |
| Path | An absolute path to a file or directory that must have changed during the update as condition for the action to be performed. Paths must be specified using forward slashes (`/`) and if the path is to a directory it must terminate with a forward slash `/`.<br/></br>If you specify a path to a file, the file must have changed to satisfy the condition.</br>If you specify a path to a directory, a file in that directory or any of its subdirectories must have changed to satisfy the condition.|
| On | A list of file operations (`created`, `updated`, `removed`) to further limit the kind of changes to the specified path as condition for the action to be performed. |

If you have specified a "path condition" for an action in the `afterUpdating` hook, you have the following variables that you can include in arguments to your command and that will be replaced with the absolute path(s) to the changed files:

| Variable | Description |
| -------- | ----------- |
| `{{ Path }}` | The absolute path to the file or directory specified in the path condition. |
| `{{ Files }}` | A space-separated list of absolute paths of the files that were changed (created, updated, or removed) during the update and are covered by the path condition. |
| `{{ CreatedFiles }}` | A space-separated list of absolute paths of the files that were changed (created, updated, or removed) during the update and are covered by the path condition. |
| `{{ UpdatedFiles }}` | A space-separated list of absolute paths of the files that were updated during the update and are covered by the path condition. |
| `{{ RemovedFiles }}` | A space-separated list of absolute paths of the files that were removed during the update and are covered by the path condition. |

The Flight Control Agent comes with a built-in set of rules defined in `/usr/lib/flightctl/hooks.d/afterupdating/00-default.yaml`:

| If files changed below | then the agent runs | Description |
| ------------------------ | -------------- | ----------- |
| `/etc/systemd/system/` | `systemctl daemon-reload` | Changes to systemd units will be activated by signaling the systemd daemon to reload the systemd manager configuration. This will rerun all generators, reload all unit files, and recreate the entire dependency tree. |
| `/etc/NetworkManager/system-connections/` | `nmcli conn reload` | Changes to Network Manager system connections will be activated by signaling Network Manager to reload all connections. |
| `/etc/firewalld/` | `firewall-cmd --reload` | Changes to firewalld's permanent configuration will be activated by signaling firewalld to reload firewall rules as new runtime configuration. |

### Using Device Lifecycle Hooks on the Web UI

### Using Device Lifecycle Hooks on the CLI

To add a device lifecycle hook, specify it in the device's `spec.hooks` as follows:

```yaml
apiVersion: v1alpha1
kind: Device
metadata:
  name: some_device_name
spec:
[...]
  hooks:
    afterUpdating:
    # a simple command with arguments (note: specify absolute path to binary)
    - run: /usr/bin/echo "called from afterUpdating hook"
    # a second command, this time running a shell and using environment
    # variables, working directory, and timeout
    - run: /usr/bin/bash -c "echo ${MESSAGE}"
      envVars:
        MESSAGE: "called from afterUpdating hook"
      timeout: 10s
      workDir: /
    # a third command, this time with a path condition that runs the command
    # only if a file below /etc/systemd/system/ has been changed and prints
    # the paths of the changed files
    - if:
        path: "/etc/systemd/system/"
        op: [Create, Update, Remove]
      run: /usr/bin/echo "{{ Files }}"
[...]
```

## Monitoring Device Resources

You can set up monitors for device resources and define alerts when the utilization of these resources crosses a defined threshold. When the agent alerts the Flight Control service, the service sets the device status to "degraded" or "error" (depending on the severity level) and may suspend the rollout of updates and alarm the user as a result.

Note this is not meant to replace an observability solution. If your use case requires streaming logs and metrics from devices into an observability stack and the device's network bandwidth allows this, see [Adding Device Observability](adding-device-observability.md) for ways to approach that.

Resource monitors take the following parameters:

| Parameter | Description |
| --------- | ----------- |
| MonitorType | The resource to monitor. Currently supported resources are "CPU", "Memory", and "Disk". **[TODO: Check whether the "Custom" resource type is implemented.]** |
| SamplingInterval | The interval in which the monitor samples utilization, specified as positive integer followed by a time unit ('s' for seconds, 'm' for minutes, 'h' for hours). |
| AlertRules | A list of alert rules. |
| Path | (Disk monitor only) The absolute path to the directory to monitor. Utilization reflects the filesystem containing the path, similar to df, even if it’s not a mount point. |

Alert rules take the following parameters:

| Parameter | Description |
| --------- | ----------- |
| Severity | The alert rule's severity level out of "Info", "Warning", or "Critical". Only one alert rule is allowed per severity level and monitor. |
| Duration | The duration that resource utilization is measured and averaged over when sampling, specified as positive integer followed by a time unit ('s' for seconds, 'm' for minutes, 'h' for hours). Must be smaller than the sampling interval. |
| Percentage | The utilization threshold that triggers the alert, as percentage value (range 0 to 100 without the "%" sign). |
| Description | A human-readable description of the alert. This is useful for adding details about the alert that might help with debugging. By default it populates the alert as <severity>: <type> load is above <percentage>>% for more than <duration>  |

### Monitoring Device Resources on the Web UI

### Monitoring Device Resources on the CLI

To monitor resource utilization, add resource monitors in the `resources:` section of the device's specification.

For example, to monitor disk utilization on the filesystem associated with the path /applications, which can trigger a warning alert if the average utilization exceeds 75% for more than 30 minutes and a critical alert if it exceeds 90% for over 10 minutes with a sampling interval of 5 seconds.

```yaml
apiVersion: v1alpha1
kind: Device
metadata:
  name: some_device_name
spec:
[...]
  resources:
  - monitorType: Disk
    samplingInterval: 5s
    path: /application_data
    alertRules:
    - severity: Warning
      duration: 30m
      percentage: 75
      description: Disk space for application data is >75% full for over 30m.
    - severity: Critical
      duration: 10m
      percentage: 90
      description: Disk space for application data is >90% full over 10m.
[...]
```

## Accessing Devices Remotely (experimental)

For troubleshooting an edge device, a user can be authorized to remotely connect to that device's console through the agent. This does not require an SSH connection and so works even if that device is on a private network (behind a NAT), has a dynamic IP address, or has its SSH service disabled.

### Accessing Devices on the Web UI

### Accessing Devices on the CLI

To connect, use the `flightctl console` command specifying the device's name, and the agent will establish the console connection the next time it calls home (pull mode) or instantaneously (push mode):

```console
flightctl console <some_device_name>
```

To disconnect, enter "exit" on the console. To force-disconnect, press `<ctrl>+b` three times.

## Decommissioning Devices
