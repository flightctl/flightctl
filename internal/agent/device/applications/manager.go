package applications

import (
	"context"
	"fmt"

	"github.com/flightctl/flightctl/api/v1alpha1"
	"github.com/flightctl/flightctl/internal/agent/client"
	"github.com/flightctl/flightctl/pkg/log"
)

type manager struct {
	podmanMonitor *PodmanMonitor
	log           *log.PrefixLogger
}

func NewManager(log *log.PrefixLogger, podmanClient *client.Podman) Manager {
	return &manager{
		podmanMonitor: NewPodmanMonitor(log, podmanClient),
		log:           log,
	}
}

func (m *manager) Run(ctx context.Context) {
	if err := m.podmanMonitor.Run(ctx); err != nil {
		m.log.Errorf("error running podman monitor: %v", err)
	}
	<-ctx.Done()
}

// Add an application to be managed
func (m *manager) Add(app Application) error {
	appType := app.Type()
	switch appType {
	case AppCompose:
		return m.podmanMonitor.add(app)
	default:
		return fmt.Errorf("%w: %s", ErrorUnsupportedAppType, appType)
	}
}

// Remove by name
func (m *manager) Remove(app Application) error {
	appType := app.Type()
	switch appType {
	case AppCompose:
		return m.podmanMonitor.remove(app)
	default:
		return fmt.Errorf("%w: %s", ErrorUnsupportedAppType, appType)
	}
}

// Update an application
func (m *manager) Update(app Application) error {
	appType := app.Type()
	switch appType {
	case AppCompose:
		return m.podmanMonitor.update(app)
	default:
		return fmt.Errorf("%w: %s", ErrorUnsupportedAppType, appType)
	}
}

// ExecuteActions executes actions generated by the manager during reconciliation.
func (m *manager) ExecuteActions(ctx context.Context) error {
	// execute actions for applications using the podman runtime this includes compose.
	return m.podmanMonitor.ExecuteActions(ctx)
}

func (m *manager) Status() ([]v1alpha1.DeviceApplicationStatus, v1alpha1.ApplicationsSummaryStatusType, error) {
	return m.podmanMonitor.Status()
}
