package applications

import (
	"context"
	"fmt"

	"github.com/flightctl/flightctl/api/v1alpha1"
	"github.com/flightctl/flightctl/internal/agent/client"
	"github.com/flightctl/flightctl/pkg/executer"
	"github.com/flightctl/flightctl/pkg/log"
)

type manager struct {
	podmanMonitor *PodmanMonitor
	log           *log.PrefixLogger
}

func NewManager(log *log.PrefixLogger, exec executer.Executer, podmanClient *client.Podman) Manager {
	return &manager{
		podmanMonitor: NewPodmanMonitor(log, exec, podmanClient),
		log:           log,
	}
}

// Add an application to be managed
func (m *manager) Add(app Application) error {
	appType := app.Type()
	switch appType {
	case AppCompose:
		return m.podmanMonitor.add(app)
	default:
		return fmt.Errorf("%w: %s", ErrorUnsupportedAppType, appType)
	}
}

// Remove by name
func (m *manager) Remove(app Application) error {
	appType := app.Type()
	switch appType {
	case AppCompose:
		return m.podmanMonitor.remove(app)
	default:
		return fmt.Errorf("%w: %s", ErrorUnsupportedAppType, appType)
	}
}

// Update an application
func (m *manager) Update(app Application) error {
	appType := app.Type()
	switch appType {
	case AppCompose:
		return m.podmanMonitor.update(app)
	default:
		return fmt.Errorf("%w: %s", ErrorUnsupportedAppType, appType)
	}
}

// ExecuteActions executes actions generated by the manager during reconciliation.
func (m *manager) ExecuteActions(ctx context.Context) error {
	// execute actions for applications using the podman runtime this includes
	// compose and quadlets.
	if err := m.podmanMonitor.ExecuteActions(ctx); err != nil {
		return fmt.Errorf("error executing actions: %w", err)
	}
	return nil
}

func (m *manager) Status() ([]v1alpha1.DeviceApplicationStatus, v1alpha1.ApplicationsSummaryStatusType, error) {
	return m.podmanMonitor.Status()
}
