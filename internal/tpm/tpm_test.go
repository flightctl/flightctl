//go:build amd64 || arm64

package tpm

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/sha256"
	"crypto/x509"
	"encoding/asn1"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"os"
	"testing"

	"github.com/google/go-tpm-tools/client"
	"github.com/google/go-tpm-tools/simulator"
	legacy "github.com/google/go-tpm/legacy/tpm2"
	"github.com/google/go-tpm/tpm2"
	"github.com/stretchr/testify/require"
)

type TestFixture struct {
	tpm *TPM
}

type TestData struct {
	tpm    *TPM
	srk    *tpm2.NamedHandle
	ldevid *tpm2.NamedHandle
	lak    *client.Key
	nonce  []byte
	pcrSel *legacy.PCRSelection
}

func openTPMSimulator(t *testing.T) (*TPM, error) {
	t.Helper()
	require := require.New(t)

	simulator, err := simulator.Get()
	require.NoError(err)

	tpm := &TPM{
		conn:    simulator,
		cleanup: func() error { return simulator.Close() },
	}

	// Auto-generate keys like OpenTPM does
	_, err = tpm.generateSRKPrimary()
	require.NoError(err)

	_, err = tpm.createLDevID()
	require.NoError(err)

	_, err = tpm.getLDevIDPubKey()
	require.NoError(err)

	return tpm, nil
}

func setupTestFixture(t *testing.T) (*TestFixture, error) {
	t.Helper()

	tpm, err := openTPMSimulator(t)
	if err != nil {
		return nil, fmt.Errorf("unable to open tpm simulator: %w", err)
	}

	return &TestFixture{tpm: tpm}, nil
}

func setupTestData(t *testing.T) TestData {
	t.Helper()
	require := require.New(t)

	f, err := setupTestFixture(t)
	require.NoError(err)

	lak, err := f.tpm.CreateLAK()
	require.NoError(err)

	nonce := make([]byte, 8)
	_, err = io.ReadFull(rand.Reader, nonce)
	require.NoError(err)

	selection := client.FullPcrSel(legacy.AlgSHA256)

	data := TestData{
		tpm:    f.tpm,
		srk:    f.tpm.srk,
		ldevid: f.tpm.ldevid,
		lak:    lak,
		nonce:  nonce,
		pcrSel: &selection,
	}

	return data
}

func TestLAK(t *testing.T) {
	data := setupTestData(t)
	defer func() {
		data.tpm.Close()
		data.lak.Close()
	}()

	// This template is based on that used for AK ECC key creation in go-tpm-tools, see:
	// https://github.com/google/go-tpm-tools/blob/3e063ade7f302972d7b893ca080a75efa3db5506/client/template.go#L108
	//
	// For more template options, see https://pkg.go.dev/github.com/google/go-tpm/legacy/tpm2#Public
	params := legacy.ECCParams{
		Symmetric: nil,
		CurveID:   legacy.CurveNISTP256,
		Point: legacy.ECPoint{
			XRaw: make([]byte, 32),
			YRaw: make([]byte, 32),
		},
	}
	params.Sign = &legacy.SigScheme{
		Alg:  legacy.AlgECDSA,
		Hash: legacy.AlgSHA256,
	}
	template := legacy.Public{
		Type:          legacy.AlgECC,
		NameAlg:       legacy.AlgSHA256,
		Attributes:    legacy.FlagSignerDefault,
		ECCParameters: &params,
	}

	pub := data.lak.PublicArea()
	if !pub.MatchesTemplate(template) {
		t.Errorf("local attestation key does not match template")
	}
}

func TestGetQuote(t *testing.T) {
	require := require.New(t)
	data := setupTestData(t)
	defer func() {
		data.tpm.Close()
		data.lak.Close()
	}()

	_, err := data.tpm.GetQuote(data.nonce, data.lak, data.pcrSel)
	require.NoError(err)
}

func TestGetAttestation(t *testing.T) {
	// Skip this test when running in a CI environment where the event log file is not available
	_, err := os.ReadFile("/sys/kernel/security/tpm0/binary_bios_measurements")
	if errors.Is(err, fs.ErrNotExist) || errors.Is(err, fs.ErrPermission) {
		t.Skip("Skipping test: TCG Event Log not available")
	}

	require := require.New(t)
	data := setupTestData(t)
	defer func() {
		data.tpm.Close()
		data.lak.Close()
	}()

	_, err = data.tpm.GetAttestation(data.nonce, data.lak)
	require.NoError(err)
}

func TestGetPCRValues(t *testing.T) {
	require := require.New(t)
	data := setupTestData(t)
	defer func() {
		data.tpm.Close()
		data.lak.Close()
	}()

	measurements := make(map[string]string)

	err := data.tpm.GetPCRValues(measurements)
	require.NoError(err)
}

func TestSimpleTPMSetup(t *testing.T) {
	require := require.New(t)

	tpm, err := openTPMSimulator(t)
	require.NoError(err, "should be able to open TPM simulator")
	defer tpm.Close()

	// SRK and LDevID are already generated by openTPMSimulator
	require.NotNil(tpm.srk, "SRK should not be nil")
	require.NotNil(tpm.ldevid, "LDevID should not be nil")

	lak, err := tpm.CreateLAK()
	require.NoError(err, "should be able to create LAK")
	require.NotNil(lak, "LAK should not be nil")
	defer lak.Close()
}

// Helper function to verify ECDSA signatures
func verifyECDSASignature(pubKey *ecdsa.PublicKey, data []byte, signature []byte) error {
	// Parse ASN.1 encoded signature
	var sig ecdsaSignature
	_, err := asn1.Unmarshal(signature, &sig)
	if err != nil {
		return fmt.Errorf("failed to parse signature: %w", err)
	}

	// Hash the data
	hash := sha256.Sum256(data)

	// Verify signature
	if !ecdsa.Verify(pubKey, hash[:], sig.R, sig.S) {
		return fmt.Errorf("signature verification failed")
	}

	return nil
}

func TestGetLDevIDPubKey(t *testing.T) {
	t.Run("successful retrieval", func(t *testing.T) {
		require := require.New(t)
		data := setupTestData(t)
		defer func() {
			data.tpm.Close()
			data.lak.Close()
		}()
		pubKey, err := data.tpm.getLDevIDPubKey()
		require.NoError(err)
		require.NotNil(pubKey)

		// Verify it's an ECDSA public key
		ecdsaPubKey, ok := pubKey.(*ecdsa.PublicKey)
		require.True(ok, "public key should be *ecdsa.PublicKey")

		// Verify it's P-256 curve
		require.Equal("P-256", ecdsaPubKey.Curve.Params().Name)

		// Verify coordinates are valid
		require.True(ecdsaPubKey.X.Sign() > 0, "X coordinate should be positive")
		require.True(ecdsaPubKey.Y.Sign() > 0, "Y coordinate should be positive")
	})

	t.Run("error when ldevid not initialized", func(t *testing.T) {
		require := require.New(t)
		// Create TPM without auto-generation to test error case
		simulator, err := simulator.Get()
		require.NoError(err)
		tpm := &TPM{
			conn:    simulator,
			cleanup: func() error { return simulator.Close() },
		}
		defer tpm.Close()

		_, err = tpm.getLDevIDPubKey()
		require.Error(err)
		require.Contains(err.Error(), "ldevid not initialized")
	})
}

func TestSign(t *testing.T) {
	require := require.New(t)
	data := setupTestData(t)
	defer func() {
		data.tpm.Close()
		data.lak.Close()
	}()

	// TPM Sign expects a 32-byte hash (SHA-256)
	testHash := sha256.Sum256([]byte("test data to sign"))

	t.Run("successful signing", func(t *testing.T) {
		signature, err := data.tpm.Sign(nil, testHash[:], nil)
		require.NoError(err)
		require.NotEmpty(signature)

		// Verify signature is ASN.1 encoded
		var sig ecdsaSignature
		_, err = asn1.Unmarshal(signature, &sig)
		require.NoError(err)
		require.NotNil(sig.R)
		require.NotNil(sig.S)
		require.True(sig.R.Sign() > 0, "R should be positive")
		require.True(sig.S.Sign() > 0, "S should be positive")
	})

	t.Run("signing different hash inputs", func(t *testing.T) {
		testCases := []struct {
			name     string
			origData []byte
		}{
			{"empty data hash", []byte{}},
			{"small data hash", []byte("hello")},
			{"medium data hash", make([]byte, 256)},
			{"large data hash", make([]byte, 1024)},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Hash the data first since TPM expects a digest
				hash := sha256.Sum256(tc.origData)
				signature, err := data.tpm.Sign(rand.Reader, hash[:], crypto.SHA256)
				require.NoError(err)
				require.NotEmpty(signature)
			})
		}
	})

	t.Run("rand parameter is ignored", func(t *testing.T) {
		// Sign with nil rand
		sig1, err := data.tpm.Sign(nil, testHash[:], nil)
		require.NoError(err)

		// Sign with real rand - should still work (rand is ignored)
		sig2, err := data.tpm.Sign(rand.Reader, testHash[:], nil)
		require.NoError(err)

		// Both signatures should be valid (though different due to randomness)
		require.NotEmpty(sig1)
		require.NotEmpty(sig2)
	})
}

func TestSignAndVerify(t *testing.T) {
	require := require.New(t)
	data := setupTestData(t)
	defer func() {
		data.tpm.Close()
		data.lak.Close()
	}()

	t.Run("sign and verify integration", func(t *testing.T) {
		testPayloads := [][]byte{
			[]byte("test message 1"),
			[]byte("another test message"),
			[]byte(""),
			make([]byte, 100), // filled with zeros
		}

		// Get public key
		pubKey, err := data.tpm.getLDevIDPubKey()
		require.NoError(err)
		ecdsaPubKey := pubKey.(*ecdsa.PublicKey)

		for i, payload := range testPayloads {
			t.Run(fmt.Sprintf("payload_%d", i), func(t *testing.T) {
				// Hash the payload since TPM expects a digest
				hash := sha256.Sum256(payload)

				// Sign the hash
				signature, err := data.tpm.Sign(rand.Reader, hash[:], crypto.SHA256)
				require.NoError(err)

				// Verify the signature against the original payload
				err = verifyECDSASignature(ecdsaPubKey, payload, signature)
				require.NoError(err, "signature verification should succeed")
			})
		}
	})

	t.Run("verification fails with wrong data", func(t *testing.T) {
		originalData := []byte("original data")
		wrongData := []byte("wrong data")

		// Get public key
		pubKey, err := data.tpm.getLDevIDPubKey()
		require.NoError(err)
		ecdsaPubKey := pubKey.(*ecdsa.PublicKey)

		// Hash and sign original data
		originalHash := sha256.Sum256(originalData)
		signature, err := data.tpm.Sign(rand.Reader, originalHash[:], crypto.SHA256)
		require.NoError(err)

		// Try to verify with wrong data - should fail
		err = verifyECDSASignature(ecdsaPubKey, wrongData, signature)
		require.Error(err, "verification should fail with wrong data")
	})
}

func TestReadEndorsementKeyCert(t *testing.T) {
	tests := []struct {
		name               string
		setupTPM           func(t *testing.T) *TPM
		useTestMethod      bool
		expectError        bool
		expectedErrContent string
		expectedCertType   string
	}{
		{
			name: "no connection available",
			setupTPM: func(t *testing.T) *TPM {
				return &TPM{conn: nil}
			},
			useTestMethod:      false,
			expectError:        true,
			expectedErrContent: "no connection available",
		},
		{
			name: "RSA EK certificate found",
			setupTPM: func(t *testing.T) *TPM {
				t.Skip("Skipping endorsement key certificate test: TPM simulator does not provide EK certificates")
				return nil
			},
			useTestMethod:    true,
			expectError:      false,
			expectedCertType: "RSA EK Certificate",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			require := require.New(t)
			tpm := tc.setupTPM(t)
			defer func() {
				_ = tpm.Close()
			}()

			certData, err := tpm.EndorsementKeyCert()

			if tc.expectError {
				require.Error(err)
				require.Contains(err.Error(), tc.expectedErrContent)
				return
			}

			require.NoError(err)
			require.NotEmpty(certData)

			// Verify it's a valid X.509 certificate with expected type
			cert, err := x509.ParseCertificate(certData)
			require.NoError(err)
			require.Contains(cert.Subject.CommonName, tc.expectedCertType)
		})
	}
}

func TestCryptoSignerInterface(t *testing.T) {
	data := setupTestData(t)
	defer func() {
		_ = data.tpm.Close()
		data.lak.Close()
	}()

	t.Run("TPM implements crypto.Signer", func(t *testing.T) {
		require := require.New(t)
		// Verify TPM implements crypto.Signer interface
		var signer crypto.Signer = data.tpm
		require.NotNil(signer)

		// Test Public() method
		pubKey := signer.Public()
		require.NotNil(pubKey)

		ecdsaPubKey, ok := pubKey.(*ecdsa.PublicKey)
		require.True(ok, "public key should be *ecdsa.PublicKey")
		require.Equal("P-256", ecdsaPubKey.Curve.Params().Name)
	})

	t.Run("signer-only interface test with full sign and verify", func(t *testing.T) {
		require := require.New(t)
		// This test uses TPM only as crypto.Signer interface
		testSignerInterface := func(signer crypto.Signer) error {
			testData := []byte("interface test data")
			// Hash the data since TPM expects a digest
			testHash := sha256.Sum256(testData)

			// Sign using only crypto.Signer interface
			signature, err := signer.Sign(rand.Reader, testHash[:], crypto.SHA256)
			if err != nil {
				return fmt.Errorf("signing failed: %w", err)
			}

			// Get public key using only crypto.Signer interface
			pubKey := signer.Public()
			ecdsaPubKey, ok := pubKey.(*ecdsa.PublicKey)
			if !ok {
				return fmt.Errorf("expected *ecdsa.PublicKey, got %T", pubKey)
			}

			// Verify signature against original data (verifyECDSASignature will hash it)
			return verifyECDSASignature(ecdsaPubKey, testData, signature)
		}

		// Test with TPM as crypto.Signer
		var signer crypto.Signer = data.tpm
		err := testSignerInterface(signer)
		require.NoError(err, "signer interface test should pass")
	})

	t.Run("GetSigner returns self", func(t *testing.T) {
		require := require.New(t)
		signer := data.tpm.GetSigner()
		require.Equal(data.tpm, signer, "GetSigner should return the TPM instance itself")
	})
}

func TestEndorsementKeyPublic(t *testing.T) {
	tests := []struct {
		name               string
		setupTPM           func(t *testing.T) *TPM
		expectError        bool
		expectedErrContent string
		validateResult     func(t *testing.T, data []byte)
	}{
		{
			name: "no connection available",
			setupTPM: func(t *testing.T) *TPM {
				return &TPM{conn: nil}
			},
			expectError:        true,
			expectedErrContent: "no connection available",
		},
		{
			name: "successful public key retrieval with simulator",
			setupTPM: func(t *testing.T) *TPM {
				require := require.New(t)
				tpm, err := openTPMSimulator(t)
				require.NoError(err)
				return tpm
			},
			expectError: false,
			validateResult: func(t *testing.T, data []byte) {
				require := require.New(t)
				require.NotEmpty(data, "encoded public key data should not be empty")
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			require := require.New(t)
			tpm := tc.setupTPM(t)
			defer func() {
				_ = tpm.Close()
			}()

			publicKeyData, err := tpm.EndorsementKeyPublic()

			if tc.expectError {
				require.Error(err)
				require.Contains(err.Error(), tc.expectedErrContent)
				require.Empty(publicKeyData)
				return
			}

			require.NoError(err)
			if tc.validateResult != nil {
				tc.validateResult(t, publicKeyData)
			}
		})
	}
}
