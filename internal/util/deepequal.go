package util

import (
	"bytes"
	"encoding/json"
	"reflect"
	"strings"
	"unsafe"
)

func DeepEqualWithUnionHandling(v1, v2 reflect.Value) bool {
	return deepEqualWithUnionHandling(v1, v2, "")
}

func deepEqualWithUnionHandling(v1, v2 reflect.Value, indentation string) bool {
	if !v1.IsValid() || !v2.IsValid() {
		return v1.IsValid() == v2.IsValid()
	}

	if v1.Type() != v2.Type() {
		return false
	}

	// Special handling for json.RawMessage
	if v1.Type() == reflect.TypeOf(json.RawMessage{}) {
		return jsonRawMessageEqual(getJsonRawMessage(v1), getJsonRawMessage(v2), []string{})
	}

	switch v1.Kind() {
	case reflect.Struct:
		// Check each field, with special handling for union fields
		// Note: The order of the fields is deterministic - it matches the order of
		// field declarations in the struct definition. So once we validated that
		// v1 and v2 are the same type, we can compare the fields in order.
		for i := 0; i < v1.NumField(); i++ {
			field := v1.Type().Field(i)

			if field.Name == "union" && field.Type == reflect.TypeOf(json.RawMessage{}) {
				var knownFields []string
				for j := 0; j < v1.NumField(); j++ {
					f := v1.Type().Field(j)
					if f.Name != "union" {
						jsonTag := f.Tag.Get("json")
						if comma := strings.Index(jsonTag, ","); comma != -1 {
							jsonTag = jsonTag[:comma]
						}
						if jsonTag != "" && jsonTag != "-" {
							knownFields = append(knownFields, jsonTag)
						}
					}
				}

				if !jsonRawMessageEqual(getJsonRawMessage(v1.Field(i)), getJsonRawMessage(v2.Field(i)), knownFields) {
					return false
				}
			} else {
				if !deepEqualWithUnionHandling(v1.Field(i), v2.Field(i), indentation+"  ") {
					return false
				}
			}
		}
		return true

	case reflect.Slice, reflect.Array:
		if v1.Len() != v2.Len() {
			return false
		}
		for i := 0; i < v1.Len(); i++ {
			if !deepEqualWithUnionHandling(v1.Index(i), v2.Index(i), indentation+"  ") {
				return false
			}
		}
		return true

	case reflect.Map:
		if v1.Len() != v2.Len() {
			return false
		}
		for _, key := range v1.MapKeys() {
			val1 := v1.MapIndex(key)
			val2 := v2.MapIndex(key)
			if !val2.IsValid() || !deepEqualWithUnionHandling(val1, val2, indentation+"  ") {
				return false
			}
		}
		return true

	case reflect.Ptr, reflect.Interface:
		if v1.IsNil() != v2.IsNil() {
			return false
		}
		if v1.IsNil() {
			return true
		}
		return deepEqualWithUnionHandling(v1.Elem(), v2.Elem(), indentation+"  ")

	default:
		// For primitive types, use standard comparison
		return reflect.DeepEqual(v1.Interface(), v2.Interface())
	}
}

// getJsonRawMessage safely extracts json.RawMessage from a reflect.Value, even if unexported
func getJsonRawMessage(v reflect.Value) json.RawMessage {
	if !v.IsValid() {
		return nil
	}

	if v.CanInterface() {
		return v.Interface().(json.RawMessage)
	}

	// For unexported fields, we need to use unsafe to access the value
	// This is the same pattern used internally by reflect.DeepEqual
	if v.Type() == reflect.TypeOf(json.RawMessage{}) {
		// Get the underlying slice data
		ptr := unsafe.Pointer(v.UnsafeAddr())
		return *(*json.RawMessage)(ptr)
	}

	return nil
}

// jsonRawMessageEqual compares two json.RawMessage values for semantic equality,
// while ignoring a given set of top-level fields.
//
// This is specifically used for comparing "union" fields generated by oapi-codegen,
// which store the full original JSON input (including top-level fields that are also
// separately represented as typed struct fields). After a JSON round-trip, the union
// may include extra keys like "name", "appType", etc., even though these are not part
// of the union type itself.
//
// To ensure logical equality, this function unmarshals the raw JSON into generic objects,
// removes the specified top-level fields, and then compares the remaining structure
// using reflect.DeepEqual.
func jsonRawMessageEqual(raw1, raw2 json.RawMessage, ignoreFields []string) bool {
	// Handle nil/empty cases
	if len(raw1) == 0 && len(raw2) == 0 {
		return true
	}

	// Quick byte comparison first (optimization for identical JSON)
	if len(raw1) == len(raw2) && bytes.Equal(raw1, raw2) {
		return true
	}

	// Semantic comparison by unmarshaling
	obj1 := decodeAndPrune(raw1, ignoreFields)
	obj2 := decodeAndPrune(raw2, ignoreFields)

	ret := reflect.DeepEqual(obj1, obj2)
	return ret
}

func decodeAndPrune(raw json.RawMessage, ignoreFields []string) interface{} {
	if len(raw) == 0 {
		return nil
	}

	var obj interface{}
	if err := json.Unmarshal(raw, &obj); err != nil {
		return nil // treat as not equal
	}

	// If it's a map, remove ignored fields
	if m, ok := obj.(map[string]interface{}); ok {
		for _, field := range ignoreFields {
			delete(m, field)
		}
	}

	if m, ok := obj.(map[string]interface{}); ok && len(m) == 0 {
		return nil
	}

	return obj
}
