package decommission_test

import (
	"fmt"

	"github.com/flightctl/flightctl/api/core/v1beta1"
	"github.com/flightctl/flightctl/test/harness/e2e"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("CLI decommission test", func() {

	Context("decommission", func() {

		It("should decommission a device via CLI", Label("decommission", "81782"), func() {
			// Get harness directly - no shared package-level variable
			harness := e2e.GetWorkerHarness()

			// Enroll device and get device ID
			deviceId, _ := harness.EnrollAndWaitForOnlineStatus()
			defer func() {
				_, err := harness.ManageResource("delete", fmt.Sprintf("device/%s", deviceId))
				Expect(err).NotTo(HaveOccurred())
				_, err = harness.ManageResource("delete", fmt.Sprintf("er/%s", deviceId))
				Expect(err).NotTo(HaveOccurred())
			}()

			GinkgoWriter.Printf("decommission device with id: %s\n", deviceId)

			By("Initiating decommission via CLI")
			out, err := harness.CLI("decommission", "devices/"+deviceId)
			Expect(err).NotTo(HaveOccurred())
			GinkgoWriter.Printf("%s\n", out)
			Expect(out).To(ContainSubstring("Device scheduled for decommissioning: 200 OK:"))

			By("Waiting for decommission to complete")
			harness.WaitForDeviceContents(deviceId, "The device has completed decommissioning and will wipe its management certificate",
				func(device *v1beta1.Device) bool {
					return e2e.ConditionExists(device, "DeviceDecommissioning", "True", string(v1beta1.DecommissionStateComplete))
				}, TIMEOUT)

			// After decommission completes, the agent will wipe credentials and reboot
			By("Waiting for VM to reboot and SSH to be ready")
			Eventually(func() error {
				return harness.VM.WaitForSSHToBeReady()
			}, REBOOT_TIMOUT, POLLING).Should(Succeed())

			// After reboot, the agent restarts and generates a NEW key (since the old one was wiped).
			// This means:
			// - Certificate: should NOT exist (agent needs to re-enroll to get a new one)
			// - Key: WILL exist (newly generated by agent on startup)
			// - CSR: might exist (agent creates it for enrollment)
			// The key verification confirms the agent has started and generated a new identity.
			By("Verifying the agent management certificate no longer exists (requires re-enrollment)")
			_, err = harness.VM.RunSSH([]string{"test", "-f", AgentCertPath}, nil)
			Expect(err).To(HaveOccurred(), "Expected certificate file %s to NOT exist after decommission - agent needs to re-enroll", AgentCertPath)

			// Verify spec JSON files do not contain the old device ID after decommission
			// Note: The agent may recreate these files on startup, but they should not contain
			// the old device's data since the identity was wiped
			By("Verifying the spec JSON files do not contain the old device ID")
			specFiles := []string{DesiredSpecPath, CurrentSpecPath, RollbackSpecPath}
			for _, specFile := range specFiles {
				output, err := harness.VM.RunSSH([]string{"sudo", "cat", specFile}, nil)
				if err == nil && output.Len() > 0 {
					// File exists, verify it doesn't contain the old device ID
					Expect(output.String()).NotTo(ContainSubstring(deviceId),
						"Expected %s to NOT contain old device ID %s after decommission", specFile, deviceId)
					GinkgoWriter.Printf("Verified: %s does not contain old device ID\n", specFile)
				} else {
					// File doesn't exist or is empty - this is also acceptable
					GinkgoWriter.Printf("Verified: %s does not exist or is empty\n", specFile)
				}
			}

			// After reboot, the agent generates a new key and attempts to re-enroll with a new device ID
			// The device ID is derived from the public key hash, so a new key means a new ID
			By("Verifying the agent generates a new device ID after reboot")
			newEnrollmentId := harness.GetEnrollmentIDFromServiceLogs("flightctl-agent")
			GinkgoWriter.Printf("New enrollment ID after decommission: %s\n", newEnrollmentId)
			Expect(newEnrollmentId).NotTo(BeEmpty(), "Expected agent to generate a new enrollment ID after decommission")
			Expect(newEnrollmentId).NotTo(Equal(deviceId), "Expected new device ID to be different from the original after decommission")

			// Verify the device attempts to re-enroll on the management server
			By("Verifying the device creates a new enrollment request on the management server")
			newEnrollmentRequest := harness.WaitForEnrollmentRequest(newEnrollmentId)
			Expect(newEnrollmentRequest).NotTo(BeNil(), "Expected new enrollment request to be created on management server")
			GinkgoWriter.Printf("New enrollment request found on management server: %s\n", *newEnrollmentRequest.Metadata.Name)

			// Clean up the new device and enrollment request created after re-enrollment
			defer func() {
				_, err := harness.ManageResource("delete", fmt.Sprintf("device/%s", newEnrollmentId))
				if err != nil {
					GinkgoWriter.Printf("Warning: failed to delete new device %s: %v\n", newEnrollmentId, err)
				}
				_, err = harness.ManageResource("delete", fmt.Sprintf("er/%s", newEnrollmentId))
				if err != nil {
					GinkgoWriter.Printf("Warning: failed to delete new enrollment request %s: %v\n", newEnrollmentId, err)
				}
			}()

			// Verify the service accepts the device re-enrollment under the new ID
			By("Approving the new enrollment request")
			harness.ApproveEnrollment(newEnrollmentId, harness.TestEnrollmentApproval())
			GinkgoWriter.Printf("Approved new enrollment request: %s\n", newEnrollmentId)

			By("Verifying the re-enrolled device comes online with the new ID")
			Eventually(harness.GetDeviceWithStatusSystem, TIMEOUT, POLLING).WithArguments(
				newEnrollmentId).ShouldNot(BeNil())

			newDevice, err := harness.GetDevice(newEnrollmentId)
			Expect(err).NotTo(HaveOccurred())
			Expect(newDevice).NotTo(BeNil())
			Expect(newDevice.Status.Summary.Status).To(Equal(v1beta1.DeviceSummaryStatusOnline),
				"Expected re-enrolled device to be online")
			GinkgoWriter.Printf("Re-enrolled device %s is now online\n", newEnrollmentId)
		})
	})
})
