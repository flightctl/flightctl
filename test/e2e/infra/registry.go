package infra

import (
	"context"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"math/big"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
)

const (
	registryImage         = "registry:2"
	registryContainerName = "e2e-registry"
	registryPort          = "5000/tcp"
	// Use fixed host port so VM can reach registry at predictable address
	registryHostPort   = "5000"
	registriesConfPath = "/etc/containers/registries.conf.d/flightctl-e2e.conf"
)

// startRegistry starts a Docker registry container for E2E tests with TLS.
func (s *SatelliteServices) startRegistry(ctx context.Context) error {
	logrus.Infof("Starting registry container (reuse=%v)", s.reuse)

	// Ensure TLS certificates exist
	certDir, err := ensureRegistryCerts()
	if err != nil {
		return fmt.Errorf("failed to ensure registry certs: %w", err)
	}

	certPath := filepath.Join(certDir, "registry.crt")
	keyPath := filepath.Join(certDir, "registry.key")

	req := testcontainers.ContainerRequest{
		Image:        registryImage,
		Name:         registryContainerName,
		ExposedPorts: []string{registryHostPort + ":" + registryPort}, // Fixed host port binding
		Env: map[string]string{
			"REGISTRY_HTTP_TLS_CERTIFICATE": "/certs/registry.crt",
			"REGISTRY_HTTP_TLS_KEY":         "/certs/registry.key",
		},
		Files: []testcontainers.ContainerFile{
			{
				HostFilePath:      certPath,
				ContainerFilePath: "/certs/registry.crt",
				FileMode:          0644,
			},
			{
				HostFilePath:      keyPath,
				ContainerFilePath: "/certs/registry.key",
				FileMode:          0600,
			},
		},
		WaitingFor: wait.ForHTTP("/v2/").WithPort("5000").WithTLS(true).WithAllowInsecure(true),
	}

	// Create container with appropriate provider and network
	container, err := CreateContainer(ctx, req, s.reuse,
		WithNetwork(s.network),
		WithHostAccess(),
	)
	if err != nil {
		return fmt.Errorf("failed to start registry container: %w", err)
	}

	s.registry = container

	// Use host IP (not localhost) so VMs can reach the registry
	// Port is fixed at 5000 for predictable VM configuration
	s.RegistryHost = GetHostIP()
	s.RegistryPort = registryHostPort
	s.RegistryURL = fmt.Sprintf("%s:%s", s.RegistryHost, s.RegistryPort)

	// Configure insecure registry access (still needed because certs are self-signed)
	if err := configureInsecureRegistry(s.RegistryURL); err != nil {
		logrus.Warnf("Failed to configure insecure registry: %v", err)
	}

	logrus.Infof("Registry container started: %s (TLS enabled)", s.RegistryURL)
	return nil
}

// ensureRegistryCerts ensures TLS certificates exist for the registry.
// The CA is pre-generated by create_e2e_certs.sh and injected into VMs.
// The registry cert is generated at runtime with the current host IP, signed by the CA.
func ensureRegistryCerts() (string, error) {
	projectRoot, err := getProjectRoot()
	if err != nil {
		return "", err
	}

	certDir := filepath.Join(projectRoot, "bin", "e2e-certs", "pki", "CA")
	caKeyPath := filepath.Join(certDir, "ca.key")
	caCertPath := filepath.Join(certDir, "ca.crt")
	registryKeyPath := filepath.Join(certDir, "registry.key")
	registryCertPath := filepath.Join(certDir, "registry.crt")

	// Check if CA exists (required - created by create_e2e_certs.sh)
	if !fileExists(caKeyPath) || !fileExists(caCertPath) {
		return "", fmt.Errorf("CA certificates not found at %s - run 'make prepare-e2e-test' first", certDir)
	}

	// Always regenerate registry cert to ensure it has the current host IP
	logrus.Info("Generating registry certificate signed by CA with current host IP...")

	// Load CA key (handle both PKCS1 and PKCS8 formats)
	caKeyPEM, err := os.ReadFile(caKeyPath)
	if err != nil {
		return "", fmt.Errorf("failed to read CA key: %w", err)
	}
	caKeyBlock, _ := pem.Decode(caKeyPEM)
	if caKeyBlock == nil {
		return "", fmt.Errorf("failed to decode CA key PEM")
	}

	var caKey *rsa.PrivateKey
	// Try PKCS1 first (RSA PRIVATE KEY)
	caKey, err = x509.ParsePKCS1PrivateKey(caKeyBlock.Bytes)
	if err != nil {
		// Try PKCS8 (PRIVATE KEY)
		key, err2 := x509.ParsePKCS8PrivateKey(caKeyBlock.Bytes)
		if err2 != nil {
			return "", fmt.Errorf("failed to parse CA key (tried PKCS1 and PKCS8): %w", err2)
		}
		var ok bool
		caKey, ok = key.(*rsa.PrivateKey)
		if !ok {
			return "", fmt.Errorf("CA key is not RSA")
		}
	}

	caCertPEM, err := os.ReadFile(caCertPath)
	if err != nil {
		return "", fmt.Errorf("failed to read CA cert: %w", err)
	}
	caCertBlock, _ := pem.Decode(caCertPEM)
	if caCertBlock == nil {
		return "", fmt.Errorf("failed to decode CA cert PEM")
	}
	caCert, err := x509.ParseCertificate(caCertBlock.Bytes)
	if err != nil {
		return "", fmt.Errorf("failed to parse CA cert: %w", err)
	}

	// Generate registry key
	registryKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return "", fmt.Errorf("failed to generate registry key: %w", err)
	}

	// Create registry certificate with current host IP
	hostIP := GetHostIP()
	logrus.Infof("Registry certificate will include IP: %s", hostIP)

	serialNumber, _ := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	template := &x509.Certificate{
		SerialNumber: serialNumber,
		Subject:      pkix.Name{CommonName: "e2e-registry"},
		NotBefore:    time.Now(),
		NotAfter:     time.Now().AddDate(1, 0, 0),
		KeyUsage:     x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		DNSNames:     []string{"localhost", "e2e-registry"},
		IPAddresses:  []net.IP{net.ParseIP("127.0.0.1"), net.ParseIP(hostIP)},
	}

	// Sign with CA
	certDER, err := x509.CreateCertificate(rand.Reader, template, caCert, &registryKey.PublicKey, caKey)
	if err != nil {
		return "", fmt.Errorf("failed to create registry certificate: %w", err)
	}

	// Write registry key
	keyFile, err := os.OpenFile(registryKeyPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return "", fmt.Errorf("failed to create registry key file: %w", err)
	}
	if err := pem.Encode(keyFile, &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(registryKey)}); err != nil {
		keyFile.Close()
		return "", fmt.Errorf("failed to write registry key: %w", err)
	}
	keyFile.Close()

	// Write registry cert
	certFile, err := os.OpenFile(registryCertPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return "", fmt.Errorf("failed to create registry cert file: %w", err)
	}
	if err := pem.Encode(certFile, &pem.Block{Type: "CERTIFICATE", Bytes: certDER}); err != nil {
		certFile.Close()
		return "", fmt.Errorf("failed to write registry cert: %w", err)
	}
	certFile.Close()

	logrus.Infof("Generated registry certificate in %s (IP: %s)", certDir, hostIP)
	return certDir, nil
}

// fileExists checks if a file exists.
func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// configureInsecureRegistry adds the registry to the system's insecure registries config.
// This allows podman/skopeo to push/pull without TLS verification (for self-signed certs).
func configureInsecureRegistry(registryURL string) error {
	// Check if config already exists with this registry
	if existingConfig, err := os.ReadFile(registriesConfPath); err == nil {
		if string(existingConfig) != "" {
			logrus.Info("Insecure registry config already exists")
			return nil
		}
	}

	config := fmt.Sprintf(`[[registry]]
location = "%s"
insecure = true
`, registryURL)

	// Need sudo to write to /etc/containers/
	cmd := exec.Command("sudo", "tee", registriesConfPath)
	stdin, err := cmd.StdinPipe()
	if err != nil {
		return fmt.Errorf("failed to get stdin pipe: %w", err)
	}

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("failed to start tee command: %w", err)
	}

	if _, err := stdin.Write([]byte(config)); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}
	stdin.Close()

	if err := cmd.Wait(); err != nil {
		return fmt.Errorf("failed to write insecure registry config: %w", err)
	}

	logrus.Infof("Configured insecure registry at %s", registryURL)
	return nil
}
