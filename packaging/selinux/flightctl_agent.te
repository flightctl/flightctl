policy_module(flightctl_agent, 1.0.0)

# Security Enhanced Linux Reference
# https://pages.cs.wisc.edu/~matyas/selinux-policy/
# https://access.redhat.com/articles/6999267

# The file context type for the agent executable binary
type flightctl_agent_exec_t;
application_executable_file(flightctl_agent_exec_t)

# The file context type for agent files in /var/lib
type flightctl_agent_var_lib_t;
files_type(flightctl_agent_var_lib_t)

# The file context type for agent files in /var/log
type flightctl_agent_var_log_t;
logging_log_file(flightctl_agent_var_log_t)

# The file context type for any temporary agent files.
type flightctl_agent_tmp_t;
files_tmp_file(flightctl_agent_tmp_t)

# The primary agent process domain
type flightctl_agent_t;
init_daemon_domain(flightctl_agent_t, flightctl_agent_exec_t)
domain_type(flightctl_agent_t)
# The agent itself should run as an unconfined domain because of how many things it needs access to.
# This is done by other top-level system services, such as cron, virtd, xserver, etc. and seems
# appropriate given the massive surface area of control for the agent and the previous constant
# expansion of this policy when we attempted to explicitly list out the permissions one by one.
unconfined_domain(flightctl_agent_t)
role system_r types flightctl_agent_t;

# This is for some reason excluded by the unconfined_domain macro so add it back.
allow flightctl_agent_t self:capability2 { mac_admin mac_override };

# Custom info hook domain
type flightctl_agent_custom_info_t;
domain_type(flightctl_agent_custom_info_t)
role system_r types flightctl_agent_custom_info_t;
type flightctl_agent_custom_info_exec_t;
application_executable_file(flightctl_agent_custom_info_exec_t)
# Execute custom info scripts in their own domain flightctl_agent_custom_info_t and make it
# unconfined until further refinement is possible.
domtrans_pattern(flightctl_agent_t, flightctl_agent_custom_info_exec_t, flightctl_agent_custom_info_t)
allow flightctl_agent_t flightctl_agent_custom_info_exec_t:file entrypoint;
unconfined_domain(flightctl_agent_custom_info_t)
# This allows custom info scripts to use any executable file type since we cannot predict ahead of
# time what it would need.
allow flightctl_agent_custom_info_t file_type:file entrypoint;

# Agent hook domain
type flightctl_agent_hook_t;
domain_type(flightctl_agent_hook_t)
role system_r types flightctl_agent_hook_t;
type flightctl_agent_hook_exec_t;
application_executable_file(flightctl_agent_hook_exec_t)
# Execute hook scripts in their own domain flightctl_agent_hook_t. Make it unconfined for now as it
# needs a lot of power.
domtrans_pattern(flightctl_agent_t, flightctl_agent_hook_exec_t, flightctl_agent_hook_t)
allow flightctl_agent_t flightctl_agent_hook_exec_t:file entrypoint;
unconfined_domain(flightctl_agent_hook_t)
# This allows hook scripts to use any executable file type since we cannot predict ahead of
# time what it would need.
allow flightctl_agent_hook_t file_type:file entrypoint;

# REMOVE this once https://github.com/bootc-dev/bootc/issues/1434 is fixed. We don't want to allow
# it so as not to alter the behavior of bootc, but we can suppress the error as it has been
# determined to be inoculous by the bootc maintainer.
gen_require(`
  type unconfined_service_t;
')
dontaudit unconfined_service_t self:capability2 mac_admin;
