package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"sigs.k8s.io/yaml"
)

// OpenAPISpec represents the OpenAPI specification structure
type OpenAPISpec struct {
	Paths   map[string]map[string]Operation `yaml:"paths"`
	Servers []Server                        `yaml:"servers"`
}

// Server represents a server entry in OpenAPI spec
type Server struct {
	URL         string `yaml:"url"`
	Description string `yaml:"description"`
}

// Operation represents an OpenAPI operation as a raw map to capture all fields
type Operation map[string]interface{}

// OperationID returns the operationId field
func (o Operation) OperationID() string {
	if id, ok := o["operationId"].(string); ok {
		return id
	}
	return ""
}

// GetXRbac returns the x-rbac extension if it exists
func (o Operation) GetXRbac() (resource, action string) {
	if xrbacRaw, exists := o["x-rbac"]; exists {
		if xrbacMap, ok := xrbacRaw.(map[string]interface{}); ok {
			if res, hasResource := xrbacMap["resource"].(string); hasResource {
				resource = res
			}
			if act, hasAction := xrbacMap["action"].(string); hasAction {
				action = act
			}
		}
	}
	return
}

// EndpointMetadata contains metadata for an API endpoint.
type EndpointMetadata struct {
	// URLPattern is the URL path pattern for the endpoint.
	URLPattern string
	// Method is the HTTP method (e.g., "GET", "POST").
	Method string
	// OperationID is the unique identifier for the operation,
	// generated from an OpenAPI specification.
	OperationID string
	// Resource is the entity the operation is performed on.
	Resource string
	// Action is the specific operation being performed on the resource. with the current integration with K8 RBAC this action should be a K8 RBAC verb:
	// get, post, put, patch, delete, deletecollection
	Action string
}

// TemplateData for generating the registry file
type TemplateData struct {
	Package   string
	Endpoints []EndpointMetadata
}

const registryTemplate = `// Code generated by api-metadata-extractor. DO NOT EDIT.

package {{.Package}}

import (
	"net/http"

	"github.com/go-chi/chi/v5"
)

// EndpointMetadata contains metadata for an API endpoint
type EndpointMetadata struct {
	OperationID string
	Resource    string
	Action      string
}


// APIMetadataMap provides O(1) lookup for endpoint metadata using pattern+method as key
var APIMetadataMap = map[string]EndpointMetadata{
{{- range .Endpoints}}
	{{printf "%q" (print .Method ":" .URLPattern)}}: {
		OperationID: {{printf "%q" .OperationID}},
		Resource:    {{printf "%q" .Resource}},
		Action:      {{printf "%q" .Action}},
	},
{{- end}}
}

// GetEndpointMetadata returns metadata for a given request using the existing Chi router context
func GetEndpointMetadata(r *http.Request) (*EndpointMetadata, bool) {
	// Get the route context from the existing Chi router that already processed this request
	rctx := chi.RouteContext(r.Context())
	if rctx == nil {
		return nil, false
	}
	
	// Get the route pattern that matched in the main Chi router
	routePattern := rctx.RoutePattern()
	if routePattern == "" {
		return nil, false
	}
	
	// O(1) lookup using method:pattern as key
	key := r.Method + ":" + routePattern
	if metadata, exists := APIMetadataMap[key]; exists {
		return &metadata, true
	}
	
	return nil, false
}

`

func main() {
	if len(os.Args) != 4 {
		log.Fatal("Usage: api-metadata-extractor <openapi-file> <output-file> <package-name>")
	}

	openapiFile := os.Args[1]
	outputFile := os.Args[2]
	packageName := os.Args[3]

	// Read and parse OpenAPI spec
	data, err := os.ReadFile(openapiFile)
	if err != nil {
		log.Fatalf("Failed to read OpenAPI file: %v", err)
	}

	var spec OpenAPISpec
	if err := yaml.Unmarshal(data, &spec); err != nil {
		log.Fatalf("Failed to parse OpenAPI spec: %v", err)
	}

	// Extract server URL prefix (use first server if available)
	var serverURLPrefix string
	if len(spec.Servers) > 0 {
		serverURLPrefix = spec.Servers[0].URL
	}

	// Extract endpoint metadata
	var endpoints []EndpointMetadata

	// Sort paths for consistent ordering
	var paths []string
	for path := range spec.Paths {
		paths = append(paths, path)
	}
	sort.Strings(paths)

	for _, path := range paths {
		methods := spec.Paths[path]

		// Sort methods for consistent ordering
		var methodNames []string
		for method := range methods {
			methodNames = append(methodNames, method)
		}
		sort.Strings(methodNames)

		for _, method := range methodNames {
			operation := methods[method]
			if operation.OperationID() == "" {
				continue
			}

			// Combine server URL prefix with path pattern for full URL pattern
			urlPattern := path
			if serverURLPrefix != "" {
				urlPattern = serverURLPrefix + path
			}

			// Extract x-rbac metadata
			resource, action := operation.GetXRbac()

			endpoints = append(endpoints, EndpointMetadata{
				URLPattern:  urlPattern,
				Method:      strings.ToUpper(method),
				OperationID: operation.OperationID(),
				Resource:    resource,
				Action:      action,
			})
		}
	}

	// Generate the registry file
	tmpl, err := template.New("registry").Parse(registryTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	file, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer file.Close()

	templateData := TemplateData{
		Package:   packageName,
		Endpoints: endpoints,
	}

	if err := tmpl.Execute(file, templateData); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	fmt.Printf("Generated API metadata registry with %d endpoints using existing Chi router context\n", len(endpoints))
}
